import 'package:flutter/foundation.dart';
import 'dart:io';
import 'dart:async';
import 'dart:convert';

import 'package:google_sign_in/google_sign_in.dart';
import 'package:googleapis/drive/v3.dart' as drive;
import 'package:googleapis/sheets/v4.dart' as sheets;
import 'package:http/http.dart' as http;
import 'package:googleapis_auth/auth_io.dart' as auth;
import 'package:oauth2/oauth2.dart' as oauth2;
import 'package:url_launcher/url_launcher.dart';

import 'package:shared_preferences/shared_preferences.dart';
import 'firebase_service.dart'; // Pentru getCurrentConsultantToken

/// Service pentru integrarea cu Google Drive »ôi Google Sheets pentru salvarea datelor clien»õilor
class GoogleDriveService extends ChangeNotifier {
  static final GoogleDriveService _instance = GoogleDriveService._internal();
  factory GoogleDriveService() => _instance;
  GoogleDriveService._internal();

  // Instan»õƒÉ Firebase pentru a ob»õine consultantToken
  final NewFirebaseService _firebaseService = NewFirebaseService();

  // Google Sign In configuration (pentru mobile)
  GoogleSignIn? _googleSignIn;
  GoogleSignInAccount? _currentUser;
  
  // Desktop webview auth
  String? _accessToken;
  String? _refreshToken;
  DateTime? _tokenExpiration;
  String? _userEmail;
  String? _userName;
  String? _currentConsultantToken; // Token-ul consultantului curent
  
  // API clients
  drive.DriveApi? _driveApi;
  sheets.SheetsApi? _sheetsApi;
  
  // Background refresh timer
  Timer? _backgroundRefreshTimer;
  
  // Google OAuth2 credentials (Web client ID for desktop webview auth)
  static const String _clientId = '417121374106-54bs43o4e6o2k95n5dp3oa30aepciooi.apps.googleusercontent.com';
  static const String _clientSecret = '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';
  
  // Authentication state
  bool _isAuthenticated = false;
  bool _isConnecting = false;
  String? _lastError;
  
  // Getters
  bool get isAuthenticated => _isAuthenticated;
  bool get isConnecting => _isConnecting;
  String? get lastError => _lastError;
  GoogleSignInAccount? get currentUser => _currentUser;
  String? get userEmail => _userEmail;
  String? get userName => _userName;
  String? get sheetName => 'clienti'; // Numele fix al spreadsheet-ului

  /// VerificƒÉ dacƒÉ platforma este suportatƒÉ pentru Google Sign In
  bool _isPlatformSupported() {
    return !kIsWeb && (Platform.isAndroid || Platform.isIOS);
  }

  /// VerificƒÉ dacƒÉ este platformƒÉ desktop
  bool _isDesktopPlatform() {
    return !kIsWeb && (Platform.isWindows || Platform.isMacOS || Platform.isLinux);
  }

  /// GenereazƒÉ cheia pentru SharedPreferences pe baza consultantToken
  String _getTokenKey(String consultantToken, String suffix) {
    return 'google_${suffix}_$consultantToken';
  }

  /// Ini»õializeazƒÉ serviciul Google Drive »ôi Sheets
  Future<void> initialize() async {
    try {
      // Ob»õine consultantToken-ul curent
      _currentConsultantToken = await _firebaseService.getCurrentConsultantToken();
      
      if (_currentConsultantToken == null) {
        debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: No consultant token available - cannot proceed with initialization');
        _lastError = 'Nu s-a gƒÉsit consultantul curent';
        return;
      }
      
      if (_isPlatformSupported()) {
        // Mobile platforms - folose»ôte Google Sign In
        _googleSignIn = GoogleSignIn.instance;
        await _googleSignIn!.initialize();
        
        // VerificƒÉ dacƒÉ existƒÉ o sesiune salvatƒÉ pentru consultantul curent
        await _checkSavedAuthentication();
        
      } else if (_isDesktopPlatform()) {
        // Desktop platforms - verificƒÉ token salvat pentru consultantul curent
        await _checkSavedDesktopToken();
        
      } else {
        debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Unsupported platform detected');
        _lastError = 'Google Drive nu este suportat pe aceastƒÉ platformƒÉ';
        return;
      }
      
      // Porne»ôte timer-ul pentru refresh-ul √Æn background (la fiecare 20 minute)
      _backgroundRefreshTimer?.cancel();
      _backgroundRefreshTimer = Timer.periodic(Duration(minutes: 20), (timer) {
        refreshTokenInBackground();
      });
      
    } catch (e) {
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Error initializing: $e');
      _lastError = 'Eroare la ini»õializare: ${e.toString()}';
    }
  }

  /// VerificƒÉ dacƒÉ existƒÉ o autentificare salvatƒÉ (mobile) pentru consultantul curent
  Future<void> _checkSavedAuthentication() async {
    try {
      // Check for existing lightweight authentication
      final account = await _googleSignIn?.attemptLightweightAuthentication();
      if (account != null && _currentConsultantToken != null) {
        // VerificƒÉ dacƒÉ token-ul salvat este pentru consultantul curent
        final prefs = await SharedPreferences.getInstance();
        final savedConsultantForThisEmail = prefs.getString('mobile_consultant_${account.email}');
        
        if (savedConsultantForThisEmail == _currentConsultantToken) {
          _currentUser = account;
          await _setupApiClients();
          _isAuthenticated = true;
          _userEmail = account.email;
          _userName = account.displayName;
          debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Restored saved authentication for ${account.email} (consultant: ${_currentConsultantToken?.substring(0, 8)})');
          notifyListeners();
        } else {
          // Token-ul este pentru alt consultant, deconecteazƒÉ
          await _googleSignIn?.signOut();
          debugPrint('üîÑ GOOGLE_DRIVE_SERVICE: Signed out previous consultant\'s account');
        }
      }
    } catch (e) {
      debugPrint('‚ö†Ô∏è GOOGLE_DRIVE_SERVICE: No saved authentication found: $e');
    }
  }

  /// VerificƒÉ dacƒÉ existƒÉ un token desktop salvat pentru consultantul curent
  Future<void> _checkSavedDesktopToken() async {
    try {
      if (_currentConsultantToken == null) {
        return;
      }
      
      final prefs = await SharedPreferences.getInstance();
      
      // Generate keys for current consultant
      final accessTokenKey = _getTokenKey(_currentConsultantToken!, 'access_token');
      final refreshTokenKey = _getTokenKey(_currentConsultantToken!, 'refresh_token');
      final emailKey = _getTokenKey(_currentConsultantToken!, 'user_email');
      final nameKey = _getTokenKey(_currentConsultantToken!, 'user_name');
      final expirationKey = _getTokenKey(_currentConsultantToken!, 'token_expiration');
      
      // Try to load all keys
      final accessToken = prefs.getString(accessTokenKey);
      final refreshToken = prefs.getString(refreshTokenKey);
      final email = prefs.getString(emailKey);
      final name = prefs.getString(nameKey);
      final expirationString = prefs.getString(expirationKey);
      
              // Check if we have minimum required data
        if (accessToken != null && email != null) {
          _accessToken = accessToken;
          _refreshToken = refreshToken;
          _userEmail = email;
          _userName = name;
          
          // Parse expiration time
          if (expirationString != null) {
            // IMPORTANT: Parse as UTC to match Google's API requirements
            _tokenExpiration = DateTime.tryParse(expirationString)?.toUtc();
          } else {
            _tokenExpiration = null;
          }
          
          // Check if token is expired
          final now = DateTime.now().toUtc();
          final isExpired = _tokenExpiration != null && now.isAfter(_tokenExpiration!);
          
          // VerificƒÉ dacƒÉ token-ul a expirat »ôi √ÆncearcƒÉ sƒÉ-l refresh
          if (isExpired) {
            if (_refreshToken != null) {
              final refreshSuccess = await _refreshAccessToken();
              
              if (!refreshSuccess) {
                debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Failed to refresh token, removing saved credentials');
                await _clearSavedDesktopToken();
                return;
              }
            } else {
              debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: No refresh token available, removing saved credentials');
            await _clearSavedDesktopToken();
            return;
          }
        } else {
          debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Token is still valid, no refresh needed');
        }
        
        debugPrint('üîç GOOGLE_DRIVE_SERVICE: Setting up API clients with token...');
        await _setupApiClientsWithToken(_accessToken!);
        debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: API clients configured successfully');
        
        _isAuthenticated = true;
        debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Authentication state set to true');
        debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Restored saved desktop token for $email (consultant: ${_currentConsultantToken?.substring(0, 8)})');
        
        debugPrint('üîç GOOGLE_DRIVE_SERVICE: Notifying listeners...');
        notifyListeners();
        debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Listeners notified');
        
      } else {
        debugPrint('‚ö†Ô∏è GOOGLE_DRIVE_SERVICE: No saved tokens found for current consultant');
        debugPrint('‚ö†Ô∏è GOOGLE_DRIVE_SERVICE: Missing access token: ${accessToken == null}');
        debugPrint('‚ö†Ô∏è GOOGLE_DRIVE_SERVICE: Missing email: ${email == null}');
      }
      
    } catch (e, stackTrace) {
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Error checking saved desktop token: $e');
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Stack trace: $stackTrace');
      // √én caz de eroare, »ôterge token-urile corupte
      debugPrint('üßπ GOOGLE_DRIVE_SERVICE: Clearing potentially corrupted tokens...');
      await _clearSavedDesktopToken();
    }
    
    debugPrint('üîçüîç GOOGLE_DRIVE_SERVICE: ========== _checkSavedDesktopToken END ==========');
  }

  /// Refresh access token-ul folosind refresh token-ul
  Future<bool> _refreshAccessToken() async {
    debugPrint('üîÑüîÑ GOOGLE_DRIVE_SERVICE: ========== _refreshAccessToken START ==========');
    
    if (_refreshToken == null) {
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: No refresh token available');
      return false;
    }

    try {
      debugPrint('üîÑ GOOGLE_DRIVE_SERVICE: Refreshing access token...');
      debugPrint('üîÑ GOOGLE_DRIVE_SERVICE: Using refresh token: ${_refreshToken!.substring(0, 20)}...');
      
      debugPrint('üîÑ GOOGLE_DRIVE_SERVICE: Making POST request to Google token endpoint...');
      final response = await http.post(
        Uri.parse('https://oauth2.googleapis.com/token'),
        headers: {'Content-Type': 'application/x-www-form-urlencoded'},
        body: {
          'client_id': _clientId,
          'client_secret': _clientSecret,
          'refresh_token': _refreshToken!,
          'grant_type': 'refresh_token',
        },
      ).timeout(Duration(seconds: 30)); // Timeout pentru request

      debugPrint('üîÑ GOOGLE_DRIVE_SERVICE: Response status: ${response.statusCode}');
      debugPrint('üîÑ GOOGLE_DRIVE_SERVICE: Response body length: ${response.body.length}');

      if (response.statusCode == 200) {
        debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Token refresh request successful');
        
        final data = json.decode(response.body);
        debugPrint('üîÑ GOOGLE_DRIVE_SERVICE: Parsed response data keys: ${data.keys}');
        
        _accessToken = data['access_token'];
        debugPrint('üîÑ GOOGLE_DRIVE_SERVICE: New access token length: ${_accessToken!.length}');
        
        // CalculeazƒÉ noul timp de expirare
        final expiresIn = data['expires_in'] ?? 3600; // Default 1 orƒÉ
        _tokenExpiration = DateTime.now().toUtc().add(Duration(seconds: expiresIn));
        debugPrint('üîÑ GOOGLE_DRIVE_SERVICE: Token expires in: ${expiresIn}s');
        debugPrint('üîÑ GOOGLE_DRIVE_SERVICE: New expiration time: $_tokenExpiration (UTC: ${_tokenExpiration!.isUtc})');
        
        // SalveazƒÉ noile token-uri
        debugPrint('üîÑ GOOGLE_DRIVE_SERVICE: Saving refreshed tokens...');
        await _saveDesktopTokens(_accessToken!, _refreshToken, _userEmail!, _userName);
        debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Tokens saved successfully');
        
        debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Access token refreshed successfully');
        return true;
      } else if (response.statusCode == 400) {
        // Refresh token invalid sau expirat
        debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Refresh token invalid or expired: ${response.statusCode}');
        debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Response: ${response.body}');
        
        // »òterge refresh token-ul invalid
        _refreshToken = null;
        await _clearSavedDesktopToken();
        
        return false;
      } else {
        debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Failed to refresh token: ${response.statusCode}');
        debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Response: ${response.body}');
        return false;
      }
    } catch (e, stackTrace) {
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Error refreshing access token: $e');
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Stack trace: $stackTrace');
      
      // VerificƒÉ dacƒÉ este o eroare temporarƒÉ (network, timeout)
      if (e.toString().contains('TimeoutException') || 
          e.toString().contains('SocketException') ||
          e.toString().contains('HttpException')) {
        debugPrint('‚ö†Ô∏è GOOGLE_DRIVE_SERVICE: Network error during refresh - can retry');
        return false; // Poate fi re√Æncercat
      }
      
      return false;
    }
    
  }

  /// »òterge token-urile desktop salvate
  Future<void> _clearSavedDesktopToken() async {
    if (_currentConsultantToken == null) {
      return;
    }
    
    try {
      final prefs = await SharedPreferences.getInstance();
      
      final accessTokenKey = _getTokenKey(_currentConsultantToken!, 'access_token');
      final refreshTokenKey = _getTokenKey(_currentConsultantToken!, 'refresh_token');
      final emailKey = _getTokenKey(_currentConsultantToken!, 'user_email');
      final nameKey = _getTokenKey(_currentConsultantToken!, 'user_name');
      final expirationKey = _getTokenKey(_currentConsultantToken!, 'token_expiration');
      
      await prefs.remove(accessTokenKey);
      await prefs.remove(refreshTokenKey);
      await prefs.remove(emailKey);
      await prefs.remove(nameKey);
      await prefs.remove(expirationKey);
      
      _accessToken = null;
      _refreshToken = null;
      _tokenExpiration = null;
      _userEmail = null;
      _userName = null;
      
    } catch (e) {
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Error clearing saved tokens: $e');
    }
  }

  /// VerificƒÉ »ôi refresh token-ul √Æn background pentru a preveni expirarea
  Future<void> refreshTokenInBackground() async {
    if (!_isAuthenticated || _isDesktopPlatform() == false) {
      return; // Nu este necesarƒÉ verificarea pentru mobile sau dacƒÉ nu este autentificat
    }
    
    if (_tokenExpiration != null && DateTime.now().toUtc().isAfter(_tokenExpiration!.subtract(Duration(minutes: 30)))) {
      debugPrint('üîÑ GOOGLE_DRIVE_SERVICE: Background refresh - token expires in less than 30 minutes');
      final refreshSuccess = await _refreshAccessToken();
      if (refreshSuccess) {
        debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Background refresh successful');
        await _setupApiClientsWithToken(_accessToken!);
      } else {
        debugPrint('‚ö†Ô∏è GOOGLE_DRIVE_SERVICE: Background refresh failed');
      }
    }
  }

  /// SchimbƒÉ consultantul »ôi √ÆncarcƒÉ token-urile corespunzƒÉtoare
  Future<void> switchConsultant(String newConsultantToken) async {
    if (_currentConsultantToken == newConsultantToken) {
      return; // Acela»ôi consultant
    }
    
    // ReseteazƒÉ starea curentƒÉ
    await _resetAuthenticationState();
    
    // SchimbƒÉ la noul consultant
    _currentConsultantToken = newConsultantToken;
    
    // √éncarcƒÉ autentificarea pentru noul consultant
    if (_isPlatformSupported()) {
      await _checkSavedAuthentication();
    } else if (_isDesktopPlatform()) {
      await _checkSavedDesktopToken();
    }
    
    notifyListeners();
  }

  /// ReseteazƒÉ starea de autentificare fƒÉrƒÉ a »ôterge token-urile salvate
  Future<void> _resetAuthenticationState() async {
    _isAuthenticated = false;
    _accessToken = null;
    _refreshToken = null;
    _tokenExpiration = null;
    _userEmail = null;
    _userName = null;
    _currentUser = null;
    _driveApi = null;
    _sheetsApi = null;
    _lastError = null;
    
    // Opre»ôte timer-ul de background refresh
    _backgroundRefreshTimer?.cancel();
    _backgroundRefreshTimer = null;
  }

  /// VerificƒÉ »ôi refresh token-ul √Ænainte de utilizare
  Future<bool> _ensureValidToken() async {
    if (!_isAuthenticated) {
      debugPrint('‚ö†Ô∏è GOOGLE_DRIVE_SERVICE: Not authenticated');
      return false;
    }

    // Pentru mobile, token-ul este gestionat automat de Google Sign In
    if (_isPlatformSupported()) {
      return true;
    }

    // Pentru desktop, verificƒÉ dacƒÉ token-ul a expirat
    if (_tokenExpiration != null && DateTime.now().toUtc().isAfter(_tokenExpiration!.subtract(Duration(minutes: 15)))) {
      debugPrint('üîÑ GOOGLE_DRIVE_SERVICE: Token expires soon, refreshing...');
      if (_refreshToken != null) {
        // √éncerca refresh de 3 ori cu delay √Æntre √ÆncercƒÉri
        bool refreshSuccess = false;
        for (int attempt = 1; attempt <= 3; attempt++) {
          debugPrint('üîÑ GOOGLE_DRIVE_SERVICE: Refresh attempt $attempt/3');
          refreshSuccess = await _refreshAccessToken();
          if (refreshSuccess) {
            break;
          }
          if (attempt < 3) {
            debugPrint('üîÑ GOOGLE_DRIVE_SERVICE: Waiting 2 seconds before next attempt...');
            await Future.delayed(Duration(seconds: 2));
          }
        }
        
        if (refreshSuccess) {
          // ActualizeazƒÉ API clients cu noul token
          await _setupApiClientsWithToken(_accessToken!);
          return true;
        } else {
          debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Failed to refresh token after 3 attempts');
          // NU resetƒÉm starea complet - doar marcƒÉm cƒÉ nu este autentificat
          // Utilizatorul va fi rugat sƒÉ se reconecteze doar c√¢nd √ÆncearcƒÉ sƒÉ salveze
          _isAuthenticated = false;
          _lastError = 'Token-ul a expirat. Reconecta»õi-vƒÉ la Google Drive din SetƒÉri.';
          notifyListeners();
          return false;
        }
      } else {
        debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: No refresh token, user needs to reauthenticate');
        // NU resetƒÉm starea complet - doar marcƒÉm cƒÉ nu este autentificat
        _isAuthenticated = false;
        _lastError = 'Sesiunea a expirat. Reconecta»õi-vƒÉ la Google Drive din SetƒÉri.';
        notifyListeners();
        return false;
      }
    }

    return true;
  }

  /// ConecteazƒÉ-te la Google Drive
  Future<bool> connect() async {
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: connect() called');
    _isConnecting = true;
    _lastError = null;
    notifyListeners();
    
    try {
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Checking platform support...');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: _isPlatformSupported() = ${_isPlatformSupported()}');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: _isDesktopPlatform() = ${_isDesktopPlatform()}');
      
      if (_isPlatformSupported()) {
        debugPrint('üîß GOOGLE_DRIVE_SERVICE: Using Google Sign In (mobile)');
        await _handleGoogleSignIn();
      } else if (_isDesktopPlatform()) {
        debugPrint('üîß GOOGLE_DRIVE_SERVICE: Using desktop webview auth');
        await _handleDesktopWebviewAuth();
      } else {
        debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Platform not supported');
        _lastError = 'Platforma nu este suportatƒÉ';
        return false;
      }
      
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Connection completed, authenticated: $_isAuthenticated');
      return _isAuthenticated;
      
    } catch (e) {
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Eroare la conectare: $e');
      _lastError = 'Eroare la conectare: ${e.toString()}';
      return false;
    } finally {
      _isConnecting = false;
      notifyListeners();
    }
  }

  /// GestioneazƒÉ autentificarea prin Google Sign In (mobile)
  Future<void> _handleGoogleSignIn() async {
    try {
      final account = await _googleSignIn!.authenticate();
      if (_currentConsultantToken != null) {
        _currentUser = account;
        await _setupApiClients();
        _isAuthenticated = true;
        _userEmail = account.email;
        _userName = account.displayName;
        
        // SalveazƒÉ asocierea consultantului cu email-ul Google
        final prefs = await SharedPreferences.getInstance();
        await prefs.setString('mobile_consultant_${account.email}', _currentConsultantToken!);
        
        debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Google Sign In successful for ${account.email} (consultant: ${_currentConsultantToken?.substring(0, 8)})');
      } else {
        _lastError = 'Autentificarea a fost anulatƒÉ';
      }
    } catch (e) {
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Google Sign In failed: $e');
      _lastError = 'Autentificarea Google a e»ôuat: ${e.toString()}';
    }
  }

  /// GestioneazƒÉ autentificarea prin OAuth2 cu browser (desktop)
  Future<void> _handleDesktopWebviewAuth() async {
    try {
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Starting OAuth2 browser auth...');
      
      // OAuth2 endpoints pentru Google
      final authorizationEndpoint = Uri.parse('https://accounts.google.com/o/oauth2/v2/auth');
      final tokenEndpoint = Uri.parse('https://oauth2.googleapis.com/token');
      
      // GenereazƒÉ un redirect URI local
      final redirectUri = Uri.parse('http://localhost:8080');
      
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: OAuth2 config:');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: - clientId: $_clientId');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: - redirectUri: $redirectUri');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: - authEndpoint: $authorizationEndpoint');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: - tokenEndpoint: $tokenEndpoint');
      
      // Porne»ôte serverul HTTP local pentru a prinde redirect-ul
      final server = await HttpServer.bind('localhost', 8080);
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Local HTTP server started on localhost:8080');
      
             // CreeazƒÉ grant-ul OAuth2
       final grant = oauth2.AuthorizationCodeGrant(
         _clientId,
         authorizationEndpoint,
         tokenEndpoint,
         secret: _clientSecret,
       );
      
      // GenereazƒÉ URL-ul de autorizare cu access_type=offline pentru refresh token
      final authorizationUrl = grant.getAuthorizationUrl(
        redirectUri,
        scopes: [
          'email',
          'profile', 
          'https://www.googleapis.com/auth/drive.file',
          'https://www.googleapis.com/auth/spreadsheets'
        ],
      );
      
      // AdaugƒÉ parametri pentru offline access (refresh token)
      final authUrlWithOfflineAccess = Uri.parse('$authorizationUrl&access_type=offline&prompt=consent');
      
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Authorization URL generated with offline access');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Opening browser for authentication...');
      
      // Deschide URL-ul √Æn browser
      if (await canLaunchUrl(authUrlWithOfflineAccess)) {
        await launchUrl(authUrlWithOfflineAccess, mode: LaunchMode.externalApplication);
        debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Browser opened successfully');
      } else {
        throw Exception('Nu s-a putut deschide browser-ul');
      }
      
      // A»ôteaptƒÉ redirect-ul pe serverul local
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Waiting for redirect on local server...');
      final request = await server.first;
      
      // Extrage codul de autorizare din query parameters
      final queryParams = request.uri.queryParameters;
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Received redirect with params: ${queryParams.keys}');
      
      if (queryParams.containsKey('error')) {
        throw Exception('OAuth error: ${queryParams['error']}');
      }
      
      if (!queryParams.containsKey('code')) {
        throw Exception('Nu s-a primit codul de autorizare');
      }
      
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Authorization code received');
      
             // RƒÉspunde la browser cƒÉ s-a terminat cu succes
       final htmlResponse = '<html><body><h1>‚úÖ Autentificare reu»ôitƒÉ!</h1><p>Po»õi √Ænchide aceastƒÉ fereastrƒÉ »ôi sƒÉ te √Æntorci la aplica»õie.</p><script>window.close();</script></body></html>';
       request.response
         ..statusCode = 200
         ..headers.set('content-type', 'text/html; charset=utf-8')
         ..write(htmlResponse);
       await request.response.close();
       await server.close();
      
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Exchanging authorization code for access token...');
      
      // SchimbƒÉ codul de autorizare cu token-ul de acces
      final client = await grant.handleAuthorizationResponse(queryParams);
      _accessToken = client.credentials.accessToken;
      _refreshToken = client.credentials.refreshToken;
      
      // CalculeazƒÉ timpul de expirare
      _tokenExpiration = client.credentials.expiration ?? DateTime.now().toUtc().add(Duration(hours: 1));
      
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Access token received');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Access token length: ${_accessToken!.length}');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Refresh token available: ${_refreshToken != null}');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Token expires at: $_tokenExpiration (UTC: ${_tokenExpiration!.isUtc})');
      
      // ConfigureazƒÉ API clients cu OAuth2 client
      await _setupApiClientsWithOAuth2Client(client);
      
      // Ob»õine informa»õiile utilizatorului
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Getting user info from Google...');
      final userInfo = await _getUserInfoFromGoogle(_accessToken!);
      _userEmail = userInfo['email'];
      _userName = userInfo['name'];
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: User info - email: $_userEmail, name: $_userName');
      
      // SalveazƒÉ token-urile pentru utilizare viitoare
      await _saveDesktopTokens(_accessToken!, _refreshToken, _userEmail!, _userName);
      
      _isAuthenticated = true;
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: OAuth2 authentication successful for $_userEmail');
      
    } catch (e) {
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: OAuth2 auth failed: $e');
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Error type: ${e.runtimeType}');
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Stack trace: ${StackTrace.current}');
      _lastError = 'Autentificarea OAuth2 a e»ôuat: ${e.toString()}';
    }
  }

  /// ConfigureazƒÉ API clients cu token de acces
  Future<void> _setupApiClientsWithToken(String accessToken) async {
    debugPrint('üîßüîß GOOGLE_DRIVE_SERVICE: ========== _setupApiClientsWithToken START ==========');
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: Access token length: ${accessToken.length}');
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: Token starts with: ${accessToken.substring(0, 20)}...');
    
    try {
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Getting token expiration...');
      final expiration = _tokenExpiration ?? DateTime.now().add(Duration(hours: 1));
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Original expiration: $expiration');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Expiration isUtc: ${expiration.isUtc}');
      
      // IMPORTANT: Convert to UTC if not already UTC
      final expirationUtc = expiration.isUtc ? expiration : expiration.toUtc();
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: UTC expiration: $expirationUtc');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: UTC expiration isUtc: ${expirationUtc.isUtc}');
      
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Creating AccessToken object...');
      final accessTokenObj = auth.AccessToken('Bearer', accessToken, expirationUtc);
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: AccessToken object created');
      
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Creating AccessCredentials...');
      final credentials = auth.AccessCredentials(
        accessTokenObj,
        null,
        [
          'https://www.googleapis.com/auth/drive.file',
          'https://www.googleapis.com/auth/spreadsheets'
        ],
      );
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: AccessCredentials created');
      
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Creating authenticated HTTP client...');
      final httpClient = http.Client();
      final client = auth.authenticatedClient(httpClient, credentials);
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Authenticated HTTP client created');
      
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Creating DriveApi instance...');
      _driveApi = drive.DriveApi(client);
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: DriveApi created');
      
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Creating SheetsApi instance...');
      _sheetsApi = sheets.SheetsApi(client);
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: SheetsApi created');
      
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: API clients configured with access token successfully');
    } catch (e, stackTrace) {
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Failed to setup API clients with token: $e');
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Stack trace: $stackTrace');
      rethrow;
    }
    
    debugPrint('üîßüîß GOOGLE_DRIVE_SERVICE: ========== _setupApiClientsWithToken END ==========');
  }

  /// ConfigureazƒÉ API clients cu Google Sign In
  Future<void> _setupApiClients() async {
    try {
      // Get authorization headers using the new API
      const scopes = [
        'https://www.googleapis.com/auth/drive.file',
        'https://www.googleapis.com/auth/spreadsheets',
      ];
      
      final authHeaders = await _currentUser!.authorizationClient.authorizationHeaders(scopes);
      if (authHeaders != null) {
        final authenticateClient = GoogleAuthClient(authHeaders);
        
        _driveApi = drive.DriveApi(authenticateClient);
        _sheetsApi = sheets.SheetsApi(authenticateClient);
        
        debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: API clients configured with Google Sign In');
      } else {
        throw Exception('Nu s-au putut ob»õine headerele de autorizare');
      }
    } catch (e) {
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Failed to setup API clients: $e');
      rethrow;
    }
  }

  /// ConfigureazƒÉ API clients cu OAuth2 client
  Future<void> _setupApiClientsWithOAuth2Client(oauth2.Client oauthClient) async {
    try {
      _driveApi = drive.DriveApi(oauthClient);
      _sheetsApi = sheets.SheetsApi(oauthClient);
      
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: API clients configured with OAuth2 client');
    } catch (e) {
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Failed to setup API clients with OAuth2 client: $e');
      rethrow;
    }
  }

  /// Ob»õine informa»õiile utilizatorului de la Google
  Future<Map<String, String?>> _getUserInfoFromGoogle(String accessToken) async {
    try {
      final response = await http.get(
        Uri.parse('https://www.googleapis.com/oauth2/v2/userinfo'),
        headers: {'Authorization': 'Bearer $accessToken'},
      );
      
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        return {
          'email': data['email'],
          'name': data['name'],
        };
      } else {
        throw Exception('Failed to get user info: ${response.statusCode}');
      }
    } catch (e) {
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Failed to get user info: $e');
      return {'email': null, 'name': null};
    }
  }

  /// SalveazƒÉ token-urile desktop cu refresh token
  Future<void> _saveDesktopTokens(String accessToken, String? refreshToken, String email, String? name) async {
    debugPrint('üíæüíæ GOOGLE_DRIVE_SERVICE: ========== _saveDesktopTokens START ==========');
    debugPrint('üíæ GOOGLE_DRIVE_SERVICE: Consultant token: ${_currentConsultantToken?.substring(0, 8) ?? 'NULL'}');
    debugPrint('üíæ GOOGLE_DRIVE_SERVICE: Access token length: ${accessToken.length}');
    debugPrint('üíæ GOOGLE_DRIVE_SERVICE: Refresh token available: ${refreshToken != null}');
    debugPrint('üíæ GOOGLE_DRIVE_SERVICE: Email: $email');
    debugPrint('üíæ GOOGLE_DRIVE_SERVICE: Name: $name');
    
    try {
      debugPrint('üíæ GOOGLE_DRIVE_SERVICE: Loading SharedPreferences...');
      final prefs = await SharedPreferences.getInstance();
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: SharedPreferences loaded');
      
      final accessTokenKey = _getTokenKey(_currentConsultantToken!, 'access_token');
      final refreshTokenKey = _getTokenKey(_currentConsultantToken!, 'refresh_token');
      final emailKey = _getTokenKey(_currentConsultantToken!, 'user_email');
      final nameKey = _getTokenKey(_currentConsultantToken!, 'user_name');
      final expirationKey = _getTokenKey(_currentConsultantToken!, 'token_expiration');
      
      debugPrint('üíæ GOOGLE_DRIVE_SERVICE: Saving with keys:');
      debugPrint('üíæ GOOGLE_DRIVE_SERVICE: - access_token: $accessTokenKey');
      debugPrint('üíæ GOOGLE_DRIVE_SERVICE: - user_email: $emailKey');
      
      // Save access token
      await prefs.setString(accessTokenKey, accessToken);
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Access token saved');
      
      // Save email
      await prefs.setString(emailKey, email);
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Email saved');
      
      if (refreshToken != null) {
        debugPrint('üíæ GOOGLE_DRIVE_SERVICE: - refresh_token: $refreshTokenKey');
        await prefs.setString(refreshTokenKey, refreshToken);
        debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Refresh token saved');
      }
      
      if (name != null) {
        debugPrint('üíæ GOOGLE_DRIVE_SERVICE: - user_name: $nameKey');
        await prefs.setString(nameKey, name);
        debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Name saved');
      }
      
      if (_tokenExpiration != null) {
        // IMPORTANT: Always save as UTC for consistency with Google's API requirements
        final expirationUtc = _tokenExpiration!.isUtc ? _tokenExpiration! : _tokenExpiration!.toUtc();
        final expirationString = expirationUtc.toIso8601String();
        debugPrint('üíæ GOOGLE_DRIVE_SERVICE: - token_expiration: $expirationKey');
        debugPrint('üíæ GOOGLE_DRIVE_SERVICE: - expiration value: $expirationString (UTC: ${expirationUtc.isUtc})');
        await prefs.setString(expirationKey, expirationString);
        debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Expiration saved');
      }
      
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Desktop tokens saved with refresh token');
      
      // Verify saved tokens
      prefs.getString(accessTokenKey);
      prefs.getString(refreshTokenKey);
      prefs.getString(emailKey);
      
    } catch (e, stackTrace) {
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Failed to save desktop tokens: $e');
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Stack trace: $stackTrace');
    }
    
    debugPrint('üíæüíæ GOOGLE_DRIVE_SERVICE: ========== _saveDesktopTokens END ==========');
  }

  /// DeconecteazƒÉ consultantul curent
  Future<void> disconnect() async {
    try {
      if (_currentConsultantToken == null) {
        debugPrint('‚ö†Ô∏è GOOGLE_DRIVE_SERVICE: No consultant token for disconnect');
        return;
      }

      if (_isPlatformSupported() && _googleSignIn != null) {
        // Pe mobile, »ôterge doar asocierea consultantului cu email-ul
        if (_userEmail != null) {
          final prefs = await SharedPreferences.getInstance();
          await prefs.remove('mobile_consultant_$_userEmail');
        }
        await _googleSignIn!.signOut();
        _currentUser = null;
      }
      
      if (_isDesktopPlatform()) {
        await _clearSavedDesktopToken();
      }
      
      _driveApi = null;
      _sheetsApi = null;
      _isAuthenticated = false;
      _userEmail = null;
      _userName = null;
      _lastError = null;
      
      // Opre»ôte timer-ul de background refresh
      _backgroundRefreshTimer?.cancel();
      _backgroundRefreshTimer = null;
      
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Disconnected successfully for consultant: ${_currentConsultantToken?.substring(0, 8)}');
      notifyListeners();
      
    } catch (e) {
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Error disconnecting: $e');
      _lastError = 'Eroare la deconectare: ${e.toString()}';
    }
  }

  /// Salveaza un singur client in Google Sheets cu noua logica automata
  Future<String?> saveClientToXlsx(dynamic client) async {
    debugPrint('üöÄ GOOGLE_DRIVE_SERVICE: ===========================================');
    debugPrint('üöÄ GOOGLE_DRIVE_SERVICE: √éNCEPE SALVAREA CLIENTULUI √éN GOOGLE SHEETS');
    debugPrint('üöÄ GOOGLE_DRIVE_SERVICE: ===========================================');
    
    try {
      // VerificƒÉ »ôi refresh token-ul dacƒÉ este necesar
      final tokenValid = await _ensureValidToken();
      if (!tokenValid) {
        debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Token not valid, cannot save client');
        return 'Token expirat. Reconecta»õi-vƒÉ la Google Drive din SetƒÉri';
      }
      
      // LOG: VerificƒÉ starea de autentificare detaliatƒÉ
          // Verificare autentificare
      
      if (!_isAuthenticated) {
        debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Nu este conectat la Google Drive');
        return 'Pentru a salva datele, conecta»õi-vƒÉ la Google Drive din SetƒÉri';
      }

      if (_driveApi == null || _sheetsApi == null) {
        debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: API clients nu sunt ini»õializa»õi');
        return 'Eroare: API clients nu sunt ini»õializa»õi';
      }

      // LOG: Informa»õii despre client
      debugPrint('üë§ GOOGLE_DRIVE_SERVICE: Informa»õii client:');
      debugPrint('üë§ GOOGLE_DRIVE_SERVICE: - Nume: ${client?.name ?? 'NULL'}');
      debugPrint('üë§ GOOGLE_DRIVE_SERVICE: - Telefon: ${client?.phoneNumber ?? 'NULL'}');
      debugPrint('üë§ GOOGLE_DRIVE_SERVICE: - Type: ${client.runtimeType}');

      // 1. Gaseste sau creeaza spreadsheet-ul "clienti"
      debugPrint('üìä GOOGLE_DRIVE_SERVICE: PASUL 1 - CƒÉutare/creare spreadsheet "clienti"');
      final spreadsheetId = await _findOrCreateSpreadsheet('clienti');
      if (spreadsheetId == null) {
        debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: PASUL 1 E»òUAT - Nu s-a putut gƒÉsi/crea spreadsheet-ul');
        return _lastError ?? 'Eroare la gƒÉsirea sau crearea fi»ôierului Google Sheets.';
      }
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: PASUL 1 REU»òIT - Spreadsheet ID: $spreadsheetId');

      // 2. Gaseste sau creeaza sheet-ul pentru luna curenta
      debugPrint('üìã GOOGLE_DRIVE_SERVICE: PASUL 2 - CƒÉutare/creare sheet pentru luna curentƒÉ');
      final sheetTitle = await _findOrCreateSheet(spreadsheetId);
      if (sheetTitle == null) {
        debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: PASUL 2 E»òUAT - Nu s-a putut gƒÉsi/crea sheet-ul');
        return _lastError ?? 'Eroare la gƒÉsirea sau crearea foii de calcul pentru luna curentƒÉ.';
      }
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: PASUL 2 REU»òIT - Sheet title: $sheetTitle');

      // 3. Pregateste randul de date pentru client
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: PASUL 3 - PregƒÉtire date client');
      final clientRowData = await _prepareClientRowData(client);
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Date pregƒÉtite: ${clientRowData.length} coloane');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Con»õinut: $clientRowData');
      
      // 4. Salveaza randul in sheet
      debugPrint('üíæ GOOGLE_DRIVE_SERVICE: PASUL 4 - Salvare r√¢nd √Æn sheet');
      final success = await _appendRowToSheet(spreadsheetId, sheetTitle, clientRowData);

      if (success) {
        debugPrint('‚úÖ‚úÖ‚úÖ GOOGLE_DRIVE_SERVICE: CLIENT SALVAT CU SUCCES √éN GOOGLE SHEETS ‚úÖ‚úÖ‚úÖ');
        return null; // Succes
      } else {
        final error = _lastError ?? 'Eroare necunoscutƒÉ la salvarea datelor.';
        debugPrint('‚ùå‚ùå‚ùå GOOGLE_DRIVE_SERVICE: PASUL 4 E»òUAT - Eroare la salvarea √Æn Google Sheets: $error');
        return 'Eroare la salvarea √Æn Google Sheets: $error';
      }
      
    } catch (e, stackTrace) {
      debugPrint('üí•üí•üí• GOOGLE_DRIVE_SERVICE: EROARE CRITICƒÇ LA SALVAREA CLIENTULUI üí•üí•üí•');
      debugPrint('üí• Error: $e');
      debugPrint('üí• Stack trace: $stackTrace');
      return 'Eroare la salvarea clientului: ${e.toString()}';
    }
  }

  /// Gaseste un spreadsheet dupa nume sau il creeaza daca nu exista
  Future<String?> _findOrCreateSpreadsheet(String name) async {
    try {
      final query = "mimeType='application/vnd.google-apps.spreadsheet' and name='$name' and trashed=false";
      final response = await _driveApi!.files.list(q: query, $fields: 'files(id, name)');
      
      if (response.files != null && response.files!.isNotEmpty) {
        final fileId = response.files!.first.id!;
        return fileId;
      } else {
        final newSheet = sheets.Spreadsheet(
          properties: sheets.SpreadsheetProperties(title: name),
        );
        
        final createdSheet = await _sheetsApi!.spreadsheets.create(newSheet);
        final fileId = createdSheet.spreadsheetId!;
        return fileId;
      }
    } catch (e) {
      _lastError = 'Eroare la cƒÉutarea sau crearea fi»ôierului: $e';
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: EROARE √Æn _findOrCreateSpreadsheet: $_lastError');
      return null;
    }
  }

  /// Gaseste un sheet (tab) dupa titlu sau il creeaza daca nu exista
  Future<String?> _findOrCreateSheet(String spreadsheetId) async {
    try {
      // Genereaza titlul pentru luna si anul curent (ex: Iul 25)
      final now = DateTime.now();
      final sheetTitle = _generateRomanianSheetTitle(now);

      final spreadsheet = await _sheetsApi!.spreadsheets.get(spreadsheetId, includeGridData: false);

      final existingSheet = spreadsheet.sheets?.firstWhere(
        (s) => s.properties?.title == sheetTitle,
        orElse: () => sheets.Sheet(),
      );

      if (existingSheet?.properties?.title == sheetTitle) {
        return sheetTitle;
      } else {
        final addSheetRequest = sheets.AddSheetRequest(
          properties: sheets.SheetProperties(title: sheetTitle),
        );
        
        await _sheetsApi!.spreadsheets.batchUpdate(
          sheets.BatchUpdateSpreadsheetRequest(requests: [sheets.Request(addSheet: addSheetRequest)]),
          spreadsheetId,
        );

        // Adauga header-ul in noul sheet
        await _addHeaderToSheet(spreadsheetId, sheetTitle);
        
        return sheetTitle;
      }
    } catch (e) {
      _lastError = 'Eroare la cƒÉutarea sau crearea foii de calcul: $e';
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: EROARE √Æn _findOrCreateSheet: $_lastError');
      return null;
    }
  }

  /// AdaugƒÉ header-ul √Æn sheet-ul specificat
  Future<void> _addHeaderToSheet(String spreadsheetId, String sheetTitle) async {
    try {
      final headers = _getHeaders();
      final valueRange = sheets.ValueRange()..values = [headers];
      final range = "'$sheetTitle'!A1";
      
      await _sheetsApi!.spreadsheets.values.update(
        valueRange,
        spreadsheetId,
        range,
        valueInputOption: 'USER_ENTERED',
      );
    } catch (e) {
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: EROARE √Æn _addHeaderToSheet: $e');
      rethrow; // Re-aruncƒÉ eroarea pentru ca func»õia apelantƒÉ sƒÉ o poatƒÉ gestiona
    }
  }
  
  /// Adauga un rand de date la finalul unui sheet
  Future<bool> _appendRowToSheet(String spreadsheetId, String sheetTitle, List<dynamic> rowData) async {
    try {
      
      
      return true;
    } catch (e) {
      _lastError = 'Eroare la adƒÉugarea r√¢ndului: $e';
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: EROARE √Æn _appendRowToSheet: $_lastError');
      return false;
    }
  }
  
  /// Genereaza titlul sheet-ului cu lunile in romana (ex: Iul 25)
  String _generateRomanianSheetTitle(DateTime date) {
    final Map<int, String> romanianMonths = {
      1: 'Ian',   // Ianuarie
      2: 'Feb',   // Februarie
      3: 'Mar',   // Martie
      4: 'Apr',   // Aprilie
      5: 'Mai',   // Mai
      6: 'Iun',   // Iunie
      7: 'Iul',   // Iulie
      8: 'Aug',   // August
      9: 'Sep',   // Septembrie
      10: 'Oct',  // Octombrie
      11: 'Nov',  // Noiembrie
      12: 'Dec',  // Decembrie
    };
    
    final monthAbbr = romanianMonths[date.month] ?? 'Err';
    final yearAbbr = date.year.toString().substring(2); // Ultimii 2 cifri din an
    
    return '$monthAbbr $yearAbbr';
  }

  /// Returneaza lista de headere conform noii structuri
  List<String> _getHeaders() {
    return [
      'Client',
      'Contact',
      'Codebitor',
      'Data',
      'Status',
      'Credit Client',
      'Venit Client',
      'Credit Codebitor',
      'Venit Codebitor',
    ];
  }

  /// PregƒÉte»ôte datele clientului conform noii structuri
  Future<List<dynamic>> _prepareClientRowData(dynamic client) async {
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: _prepareClientRowData - √éNCEPUT');
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: Client type: ${client.runtimeType}');
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: Client toString: $client');
    
    try {
      // Extrage datele de baza
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Extragere date de bazƒÉ...');
      final String clientName = client.name ?? '';
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: clientName: "$clientName"');
      
      final phoneNumber1 = client.phoneNumber1 ?? client.phoneNumber ?? '';
      final phoneNumber2 = client.phoneNumber2 ?? '';
      
      // FormateazƒÉ numerele de telefon pentru a pƒÉstra primul 0
      final formattedPhone1 = _formatPhoneNumber(phoneNumber1);
      final formattedPhone2 = _formatPhoneNumber(phoneNumber2);
      
      final String contact = ([formattedPhone1, formattedPhone2].where((p) => p.isNotEmpty).join('/'));
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: phoneNumber1: "$phoneNumber1" -> "$formattedPhone1"');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: phoneNumber2: "$phoneNumber2" -> "$formattedPhone2"');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: contact: "$contact"');
      
      final String coDebitorName = client.coDebitorName ?? '';
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: coDebitorName: "$coDebitorName"');
      
      final String ziua = DateTime.now().day.toString();
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: ziua: "$ziua"');
      
      final String status = client.additionalInfo ?? client.discussionStatus ?? '';
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: status: "$status"');

      // Extrage creditele si veniturile din formData
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Extragere formData...');
      final formData = client.formData as Map<String, dynamic>? ?? {};
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: formData keys: ${formData.keys.toList()}');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: formData size: ${formData.length}');
      
      if (formData.isNotEmpty) {
        debugPrint('üîß GOOGLE_DRIVE_SERVICE: formData sample:');
        formData.forEach((key, value) {
          debugPrint('üîß GOOGLE_DRIVE_SERVICE:   $key: $value');
        });
      }
      
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Extragere credite »ôi venituri...');
      final clientCredits = _extractCredits(formData, 'client');
      final clientIncomes = _extractIncomes(formData, 'client');
      // √éncearcƒÉ "coborrower" primul (numele corect din Firebase)
      final coDebitorCredits = _extractCredits(formData, 'coborrower');
      final coDebitorIncomes = _extractIncomes(formData, 'coborrower');
      
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: clientCredits: "$clientCredits"');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: clientIncomes: "$clientIncomes"');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: coDebitorCredits: "$coDebitorCredits"');
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: coDebitorIncomes: "$coDebitorIncomes"');
      
      final rowData = [
        clientName,
        contact,
        coDebitorName,
        ziua,
        status,
        clientCredits,
        clientIncomes,
        coDebitorCredits,
        coDebitorIncomes,
      ];
      
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: Date client pregƒÉtite cu succes!');
      debugPrint('‚úÖ GOOGLE_DRIVE_SERVICE: R√¢nd final: $rowData');
      
      return rowData;
    } catch (e, stackTrace) {
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: EROARE √Æn _prepareClientRowData: $e');
      debugPrint('‚ùå GOOGLE_DRIVE_SERVICE: Stack trace: $stackTrace');
      rethrow;
    }
  }

  /// Extrage informatiile de credite pentru un tip specificat conform formatului special
  String _extractCredits(Map<String, dynamic> formData, String type) {
    List<String> credits = [];
    
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: _extractCredits pentru $type');
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: formData keys: ${formData.keys.toList()}');
    
    // CautƒÉ √Æn structura creditForms
    if (formData.containsKey('creditForms') && formData['creditForms'] is Map<String, dynamic>) {
      final creditForms = formData['creditForms'] as Map<String, dynamic>;
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: GƒÉsit creditForms cu keys: ${creditForms.keys.toList()}');
      
      if (creditForms.containsKey(type) && creditForms[type] is List) {
        final creditList = creditForms[type] as List;
        debugPrint('üîß GOOGLE_DRIVE_SERVICE: GƒÉsit lista creditForms[$type] cu ${creditList.length} elemente');
        
        for (var creditData in creditList) {
          if (creditData is Map<String, dynamic>) {
            final formattedCredit = _formatCreditSpecial(creditData);
            if (formattedCredit.isNotEmpty && !_isSelectValue(formattedCredit)) {
              credits.add(formattedCredit);
            }
          }
        }
      }
    }
    
    // Fallback - cautƒÉ »ôi √Æn structura veche pentru compatibilitate
    final creditKey = '${type}Credits';
    if (credits.isEmpty && formData.containsKey(creditKey) && formData[creditKey] is List) {
      final creditList = formData[creditKey] as List;
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: GƒÉsit lista fallback $creditKey cu ${creditList.length} elemente');
      
      for (var creditData in creditList) {
        if (creditData is Map<String, dynamic>) {
          final formattedCredit = _formatCreditSpecial(creditData);
          if (formattedCredit.isNotEmpty && !_isSelectValue(formattedCredit)) {
            credits.add(formattedCredit);
          }
        }
      }
    }
    
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: Credite formatate pentru $type: $credits');
    return credits.join('; ');
  }

  /// Extrage informatiile de venituri pentru un tip specificat conform formatului special
  String _extractIncomes(Map<String, dynamic> formData, String type) {
    List<String> incomes = [];
    
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: _extractIncomes pentru $type');
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: formData keys: ${formData.keys.toList()}');
    
    // CautƒÉ √Æn structura incomeForms
    if (formData.containsKey('incomeForms') && formData['incomeForms'] is Map<String, dynamic>) {
      final incomeForms = formData['incomeForms'] as Map<String, dynamic>;
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: GƒÉsit incomeForms cu keys: ${incomeForms.keys.toList()}');
      
      if (incomeForms.containsKey(type) && incomeForms[type] is List) {
        final incomeList = incomeForms[type] as List;
        debugPrint('üîß GOOGLE_DRIVE_SERVICE: GƒÉsit lista incomeForms[$type] cu ${incomeList.length} elemente');
        
        for (var incomeData in incomeList) {
          if (incomeData is Map<String, dynamic>) {
            final formattedIncome = _formatIncomeSpecial(incomeData);
            if (formattedIncome.isNotEmpty && !_isSelectValue(formattedIncome)) {
              incomes.add(formattedIncome);
            }
          }
        }
      }
    }
    
    // Fallback - cautƒÉ »ôi √Æn structura veche pentru compatibilitate
    final incomeKey = '${type}Incomes';
    if (incomes.isEmpty && formData.containsKey(incomeKey) && formData[incomeKey] is List) {
      final incomeList = formData[incomeKey] as List;
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: GƒÉsit lista fallback $incomeKey cu ${incomeList.length} elemente');
      
      for (var incomeData in incomeList) {
        if (incomeData is Map<String, dynamic>) {
          final formattedIncome = _formatIncomeSpecial(incomeData);
          if (formattedIncome.isNotEmpty && !_isSelectValue(formattedIncome)) {
            incomes.add(formattedIncome);
          }
        }
      }
    }
    
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: Venituri formatate pentru $type: $incomes');
    return incomes.join('; ');
  }

  /// FormateazƒÉ un venit √Æn formatul special cerut (conform how_to_save_data.md)
  String _formatIncomeSpecial(Map<String, dynamic> incomeData) {
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: _formatIncomeSpecial cu date: $incomeData');
    
    final bank = incomeData['bank']?.toString() ?? '';
    final incomeType = incomeData['incomeType']?.toString() ?? '';
    final incomeAmount = incomeData['incomeAmount']?.toString() ?? '';
    final vechime = incomeData['vechime']?.toString() ?? '';
    
    // VerificƒÉ dacƒÉ banca »ôi tipul de venit sunt valide (nu "SelecteazƒÉ")
    if (_isSelectValue(bank)) {
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Venit incomplet - selecteazƒÉ banca');
      return '';
    }
    
    if (_isSelectValue(incomeType)) {
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Venit incomplet - selecteazƒÉ tipul');
      return '';
    }
    
    // PƒÉstreazƒÉ tipul de venit √Æn formatul complet
    String incomeTypeFormatted;
    switch (incomeType.toLowerCase()) {
      case 'salariu':
        incomeTypeFormatted = 'Salariu';
        break;
      case 'pensie':
        incomeTypeFormatted = 'Pensie';
        break;
      case 'indemnizatie':
        incomeTypeFormatted = 'Indemnizatie';
        break;
      default:
        incomeTypeFormatted = incomeType;
    }
    
    // FormateazƒÉ banca
    final bankFormatted = _formatBankName(bank);
    
    // FormateazƒÉ suma cu "k" pentru mii
    final amountFormatted = _formatAmountWithK(incomeAmount);
    
    // FormateazƒÉ vechimea √Æn formatul "2a3l" (2 ani »ôi 3 luni)
    final vechimeFormatted = _formatVechimeForIncome(vechime);
    
    // Construie»ôte formatul final: "bancƒÉ:sumƒÉ(tip,vechime)" 
    // DacƒÉ suma este goalƒÉ, nu salvƒÉm venitul
    if (amountFormatted.isEmpty) {
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Venit fƒÉrƒÉ sumƒÉ - ignorat');
      return '';
    }
    
    String result = '$bankFormatted:$amountFormatted';
    
    // AdaugƒÉ informa»õiile suplimentare √Æn parantezƒÉ
    final additionalInfo = <String>[];
    additionalInfo.add(incomeTypeFormatted);
    if (vechimeFormatted.isNotEmpty) {
      additionalInfo.add(vechimeFormatted);
    }
    
    if (additionalInfo.isNotEmpty) {
      result += '(${additionalInfo.join(',')})';
    }
    
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: Venit formatat final: $result');
    return result;
  }

  /// FormateazƒÉ un credit √Æn formatul special cerut (conform how_to_save_data.md)
  String _formatCreditSpecial(Map<String, dynamic> creditData) {
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: _formatCreditSpecial cu date: $creditData');
    
    final bank = creditData['bank']?.toString() ?? '';
    final creditType = creditData['creditType']?.toString() ?? '';
    final sold = creditData['sold']?.toString() ?? '';
    final consumat = creditData['consumat']?.toString() ?? '';
    final rata = creditData['rata']?.toString() ?? '';
    final rateType = creditData['rateType']?.toString() ?? '';
    final perioada = creditData['perioada']?.toString() ?? '';
    
    // VerificƒÉ dacƒÉ banca »ôi tipul de credit sunt valide (nu "SelecteazƒÉ")
    if (_isSelectValue(bank)) {
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Credit incomplet - selecteazƒÉ banca');
      return '';
    }
    
    if (_isSelectValue(creditType)) {
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Credit incomplet - selecteazƒÉ tipul');
      return '';
    }
    
    // FormateazƒÉ banca folosind aceea»ôi logicƒÉ ca la venituri
    final bankFormatted = _formatBankName(bank);
    
    // FormateazƒÉ tipul de credit
    final creditTypeFormatted = _formatCreditType(creditType);
    
    // FormateazƒÉ sumele (sold/consumat »ôi rata)
    final amountsPart = _formatCreditAmounts(sold, consumat, rata);
    
    // DacƒÉ nu existƒÉ nicio sumƒÉ, nu salvƒÉm creditul
    if (amountsPart.isEmpty) {
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Credit fƒÉrƒÉ sume - ignorat');
      return '';
    }
    
    // FormateazƒÉ detaliile (rateType »ôi perioada)
    final detailsPart = _formatCreditDetails(rateType, perioada, creditType);
    
    // Construie»ôte formatul final: "bancƒÉ-tip: sume(detalii)"
    String result = '$bankFormatted-$creditTypeFormatted: $amountsPart';
    
    // AdaugƒÉ detaliile doar dacƒÉ existƒÉ »ôi nu sunt goale
    if (detailsPart.isNotEmpty && !_isSelectValue(detailsPart)) {
      result += '($detailsPart)';
    }
    
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: Credit formatat final: $result');
    return result;
  }

  /// FormateazƒÉ numele bƒÉncii (conform how_to_save_data.md)
  String _formatBankName(String bank) {
    switch (bank.toLowerCase()) {
      case 'alpha bank':
        return 'ALPHA';
      case 'axi ifn':
        return 'Axi';
      case 'banca romaneasca':
        return 'BR';
      case 'bcr':
        return 'BCR';
      case 'best credit':
        return 'BC';
      case 'bnp paribas':
        return 'BNP';
      case 'brd':
        return 'BRD';
      case 'brd finance':
        return 'BRDf';
      case 'banca transilvania':
        return 'BT';
      case 'bt direct':
        return 'BTd';
      case 'bt leasing':
        return 'BTl';
      case 'car':
        return 'CAR';
      case 'cec bank':
        return 'CEC';
      case 'cash':
        return 'CASH';
      case 'cetelem':
        return 'CTLM';
      case 'credit europe bank':
        return 'CreditEU';
      case 'credit24':
        return 'C24';
      case 'credex':
        return 'CREDEX';
      case 'credius':
        return 'CREDIUS';
      case 'eco finance':
        return 'EXOfin';
      case 'exim bank':
        return 'EXIM';
      case 'first bank':
        return 'FIRST';
      case 'garanti bank':
        return 'GRNTI';
      case 'happy credit':
        return 'HAPPY';
      case 'hora credit':
        return 'HORA';
      case 'icredit':
        return 'iCREDIT';
      case 'idea bank':
        return 'IDEA';
      case 'ifn':
        return 'IFN';
      case 'ing':
        return 'ING';
      case 'ing bank':
        return 'ING';
      case 'intesa sanpaolo':
        return 'INTESA';
      case 'leasing ifn':
        return 'leasingIFN';
      case 'libra bank':
        return 'LIBRA';
      case 'patria bank':
        return 'PATRIA';
      case 'pireus bank':
        return 'PIREUS';
      case 'procredit bank':
        return 'PROCREDIT';
      case 'provident':
        return 'PROVIDENT';
      case 'raiffeisen bank':
        return 'RF';
      case 'raiffeisen leasing':
        return 'RFl';
      case 'revolut':
        return 'REVOLUT';
      case 'salt bank':
        return 'SALT';
      case 'simplu credit':
        return 'SIMPLU';
      case 'tbi bank':
        return 'TBI';
      case 'unicredit':
        return 'UNICREDIT';
      case 'unicredit consumer financing':
        return 'UNICREDITcf';
      case 'unicredit leasing':
        return 'UNICREDITll';
      case 'viva credit':
        return 'VIVA';
      case 'volksbank':
        return 'VOLKS';
      default:
        // Pentru bƒÉncile necunoscute, returneazƒÉ primele 3-4 caractere
        return bank.length > 6 ? bank.substring(0, 6) : bank;
    }
  }

  /// FormateazƒÉ tipul de credit
  String _formatCreditType(String creditType) {
    switch (creditType.toLowerCase()) {
      case 'card cumparaturi':
      case 'card de cumparaturi':
        return 'cc';
      case 'nevoi personale':
        return 'np';
      case 'overdraft':
        return 'ovd';
      case 'ipotecar':
        return 'ip';
      case 'prima casa':
        return 'pc';
      default:
        return creditType.toLowerCase();
    }
  }

  /// FormateazƒÉ sumele creditului (sold/consumat »ôi rata)
  String _formatCreditAmounts(String sold, String consumat, String rata) {
    final soldFormatted = _formatAmountWithK(sold);
    final consumatFormatted = _formatAmountWithK(consumat);
    final rataFormatted = _formatAmountWithK(rata);
    
    // Construie»ôte partea cu sumele folosind cratimƒÉ √Æn loc de slash
    String amounts = '';
    if (soldFormatted.isNotEmpty || consumatFormatted.isNotEmpty) {
      // TrateazƒÉ cazurile c√¢nd una dintre sume lipse»ôte
      if (soldFormatted.isNotEmpty && consumatFormatted.isNotEmpty) {
        amounts = '$soldFormatted-$consumatFormatted';
      } else if (soldFormatted.isNotEmpty) {
        amounts = soldFormatted;
      } else if (consumatFormatted.isNotEmpty) {
        amounts = consumatFormatted;
      }
    }
    
    if (rataFormatted.isNotEmpty) {
      if (amounts.isNotEmpty) {
        amounts += ' $rataFormatted';
      } else {
        amounts = rataFormatted;
      }
    }
    
    return amounts;
  }

  /// FormateazƒÉ detaliile creditului (rateType »ôi perioada)
  String _formatCreditDetails(String rateType, String perioada, String creditType) {
    final details = <String>[];
    
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: Credit details - rateType: "$rateType", perioada: "$perioada"');
    
    // AdaugƒÉ tipul ratei dacƒÉ existƒÉ »ôi nu este "SelecteazƒÉ"
    if (rateType.isNotEmpty && !_isSelectValue(rateType)) {
      details.add(rateType);
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: AdƒÉugat rateType: $rateType');
    }
    
    // AdaugƒÉ perioada dacƒÉ existƒÉ
    if (perioada.isNotEmpty && !_isSelectValue(perioada)) {
      final period = _formatPeriod(perioada);
      if (period.isNotEmpty) {
        details.add(period);
      }
    }
    
    // Pentru anumite tipuri de credit, nu afi»ôa paranteze goale
    if (details.isEmpty) {
      final creditTypeLower = creditType.toLowerCase();
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Nu existƒÉ detalii pentru $creditTypeLower');
      
      // Pentru carduri, overdraft »ôi nevoi personale, nu e nevoie de detalii suplimentare
      if (creditTypeLower.contains('card') || 
          creditTypeLower.contains('overdraft') || 
          creditTypeLower.contains('nevoi personale')) {
        debugPrint('üîß GOOGLE_DRIVE_SERVICE: Tip de credit care nu necesitƒÉ detalii');
        return '';
      }
    }
    
    final result = details.join(',');
    debugPrint('üîß GOOGLE_DRIVE_SERVICE: Detalii credit finale: "$result"');
    
    return result;
  }

  /// FormateazƒÉ o sumƒÉ cu "k" pentru mii (5500 -> 5,5k)
  String _formatAmountWithK(String amount) {
    if (amount.isEmpty || amount == '0') return '';
    
    try {
      // EliminƒÉ virgulele existente
      final cleanAmount = amount.replaceAll(',', '');
      final numericValue = double.tryParse(cleanAmount);
      
      if (numericValue != null && numericValue > 0) {
        if (numericValue >= 1000) {
          final kValue = numericValue / 1000;
          // FormateazƒÉ cu o zecimalƒÉ dacƒÉ nu e numƒÉr √Æntreg
          if (kValue == kValue.roundToDouble()) {
            return '${kValue.round()}k';
          } else {
            return '${kValue.toStringAsFixed(1)}k';
          }
        } else {
          return numericValue.round().toString();
        }
      }
    } catch (e) {
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Eroare la formatarea sumei: $e');
    }
    
    return amount;
  }

  /// FormateazƒÉ perioada (ani/luni format)
  String _formatPeriod(String perioada) {
    if (perioada.isEmpty) return '';
    
    // DacƒÉ perioada con»õine deja formatul ani/luni (ex: "2/3"), returneazƒÉ a»ôa cum e
    if (perioada.contains('/')) {
      return perioada;
    }
    
    // √éncearcƒÉ sƒÉ parseze ca numƒÉrul de luni
    final months = int.tryParse(perioada);
    if (months != null) {
      final years = months ~/ 12;
      final remainingMonths = months % 12;
      
      if (years > 0 && remainingMonths > 0) {
        return '$years/$remainingMonths';
      } else if (years > 0) {
        return '$years/0';
      } else {
        return '0/$remainingMonths';
      }
    }
    
    return perioada;
  }

  /// FormateazƒÉ vechimea pentru venit √Æn formatul "4/3" (4 ani »ôi 3 luni)
  String _formatVechimeForIncome(String vechime) {
    if (vechime.isEmpty || _isSelectValue(vechime)) return '';
    
    try {
      // DacƒÉ con»õine deja formatul "ani/luni" (ex: "4/3"), returneazƒÉ a»ôa cum e
      if (vechime.contains('/')) {
        return vechime;
      }
      
      // DacƒÉ con»õine formatul "a" »ôi "l" (ex: "4a3l"), converte»ôte la "4/3"
      if (vechime.contains('a') && vechime.contains('l')) {
        final cleanVechime = vechime.replaceAll('a', '/').replaceAll('l', '');
        return cleanVechime;
      }
      
      // √éncearcƒÉ sƒÉ parseze ca numƒÉrul de luni total
      final totalMonths = int.tryParse(vechime);
      if (totalMonths != null) {
        final years = totalMonths ~/ 12;
        final remainingMonths = totalMonths % 12;
        
        // DacƒÉ nu are luni suplimentare, returneazƒÉ doar anii
        if (remainingMonths == 0) {
          return years.toString();
        } else {
          return '$years/$remainingMonths';
        }
      }
      
      // DacƒÉ nu poate fi parsatƒÉ, returneazƒÉ valoarea originalƒÉ
      return vechime;
    } catch (e) {
      debugPrint('üîß GOOGLE_DRIVE_SERVICE: Eroare la formatarea vechimii: $e');
      return vechime;
    }
  }

  /// VerificƒÉ dacƒÉ o valoare este "SelecteazƒÉ" √Æn diverse variante
  bool _isSelectValue(String value) {
    final lowerValue = value.toLowerCase().trim();
    return lowerValue == 'selecteazƒÉ' || 
           lowerValue == 'selecteaza' || 
           lowerValue == 'selecteaza banca' ||
           lowerValue == 'selecteaza tipul' ||
           lowerValue == 'select' ||
           lowerValue.isEmpty;
  }

  /// FormateazƒÉ numƒÉrul de telefon pentru a pƒÉstra primul 0
  String _formatPhoneNumber(String phoneNumber) {
    if (phoneNumber.isEmpty) return '';
    
    // EliminƒÉ spa»õiile »ôi caracterele speciale
    String cleaned = phoneNumber.replaceAll(RegExp(r'[^\d]'), '');
    
    // DacƒÉ numƒÉrul are 9 cifre »ôi nu √Æncepe cu 0, adaugƒÉ 0
    if (cleaned.length == 9 && !cleaned.startsWith('0')) {
      cleaned = '0$cleaned';
    }
    
    // DacƒÉ numƒÉrul are 10 cifre »ôi √Æncepe cu 0, e deja corect
    if (cleaned.length == 10 && cleaned.startsWith('0')) {
      return cleaned;
    }
    
    // DacƒÉ numƒÉrul are 12 cifre »ôi √Æncepe cu 40, √Ænlocuie»ôte cu 0
    if (cleaned.length == 12 && cleaned.startsWith('40')) {
      cleaned = '0${cleaned.substring(2)}';
    }
    
    // AdaugƒÉ un spa»õiu zero-width la √Ænceput pentru a for»õa Google Sheets sƒÉ pƒÉstreze formatul
    // Acest lucru previne convertirea automatƒÉ la numƒÉr care ar elimina primul 0
    return '\u200B$cleaned';
  }
}

/// Client HTTP customizat pentru Google Sign In
class GoogleAuthClient extends http.BaseClient {
  final Map<String, String> _headers;
  final http.Client _client = http.Client();

  GoogleAuthClient(this._headers);

  @override
  Future<http.StreamedResponse> send(http.BaseRequest request) {
    return _client.send(request..headers.addAll(_headers));
  }
} 
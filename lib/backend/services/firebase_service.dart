// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;
import 'clients_service.dart';
import 'package:firebase_auth/firebase_auth.dart';

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'backend/services/firebaseService.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyBmkOMU2YvyJyCa72Lm1D3i62xS9uVISvY',
    appId: '1:324961203074:web:aebb2c8a1fbdd12307559b',
    messagingSenderId: '324961203074',
    projectId: 'broker-app-f1n4nc3',
    authDomain: 'broker-app-f1n4nc3.firebaseapp.com',
    storageBucket: 'broker-app-f1n4nc3.firebasestorage.app',
    measurementId: 'G-RQYQ68D69W',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCr0N-3rXc_KNz5nxM4JG9cCbNLsm8rFu8',
    appId: '1:324961203074:android:a49e09c8f2d20d6807559b',
    messagingSenderId: '324961203074',
    projectId: 'broker-app-f1n4nc3',
    storageBucket: 'broker-app-f1n4nc3.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyAMxDPWmCbHRXL9qhuNxDFzY7f8IY1oHtA',
    appId: '1:324961203074:ios:7f8c65d4099a996207559b',
    messagingSenderId: '324961203074',
    projectId: 'broker-app-f1n4nc3',
    storageBucket: 'broker-app-f1n4nc3.firebasestorage.app',
    iosBundleId: 'com.example.brokerApp',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyAMxDPWmCbHRXL9qhuNxDFzY7f8IY1oHtA',
    appId: '1:324961203074:ios:7f8c65d4099a996207559b',
    messagingSenderId: '324961203074',
    projectId: 'broker-app-f1n4nc3',
    storageBucket: 'broker-app-f1n4nc3.firebasestorage.app',
    iosBundleId: 'com.example.brokerApp',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyBmkOMU2YvyJyCa72Lm1D3i62xS9uVISvY',
    appId: '1:324961203074:web:d67064b2b9ae146707559b',
    messagingSenderId: '324961203074',
    projectId: 'broker-app-f1n4nc3',
    authDomain: 'broker-app-f1n4nc3.firebaseapp.com',
    storageBucket: 'broker-app-f1n4nc3.firebasestorage.app',
    measurementId: 'G-NKE39RD50B',
  );
}

/// A utility class to handle Firebase operations in a thread-safe manner.
/// This ensures all Firebase operations run on the platform thread (main UI thread)
/// to prevent "Sending messages to native from a non-platform thread" errors.
class FirebaseThreadHandler {
  /// Private constructor for singleton pattern
  FirebaseThreadHandler._();
  
  /// The singleton instance
  static final FirebaseThreadHandler instance = FirebaseThreadHandler._();
  
  /// Executes a Firebase operation safely on the platform thread.
  /// 
  /// This method ensures the operation runs on the main UI thread, which is required
  /// for Firebase operations to avoid thread-related errors and data loss.
  /// 
  /// Example usage:
  /// ```dart
  /// final docSnapshot = await FirebaseThreadHandler.instance.executeOnPlatformThread(
  ///   () => FirebaseFirestore.instance.collection('users').doc('123').get()
  /// );
  /// ```
  Future<T> executeOnPlatformThread<T>(Future<T> Function() operation) async {
    final completer = Completer<T>();
    
    void runOperation() async {
      try {
        final result = await operation();
        if (!completer.isCompleted) {
          completer.complete(result);
        }
      } catch (e) {
        debugPrint('Error in Firebase operation: $e');
        if (!completer.isCompleted) {
          completer.completeError(e);
        }
      }
    }
    
    // Detect if we're already on the platform thread
    if (WidgetsBinding.instance.rootElement == null) {
      // Not on platform thread, schedule the operation for the next frame
      WidgetsBinding.instance.addPostFrameCallback((_) => runOperation());
    } else {
      // Already on platform thread, execute immediately
      runOperation();
    }
    
    return completer.future;
  }
  
  /// Creates a thread-safe stream for Firestore queries.
  /// 
  /// This method wraps a Firestore query stream to ensure all operations are on the 
  /// platform thread and properly managed.
  /// 
  /// Example usage:
  /// ```dart
  /// final stream = FirebaseThreadHandler.instance.createSafeQueryStream(
  ///   () => FirebaseFirestore.instance.collection('users').snapshots()
  /// );
  /// ```
  Stream<QuerySnapshot> createSafeQueryStream(Stream<QuerySnapshot> Function() queryStream) {
    // Create a stream controller that will be responsible for the stream management
    final controller = StreamController<QuerySnapshot>.broadcast();
    
    // Set up proper cancellation handler
    StreamSubscription? subscription;
    controller.onCancel = () {
      subscription?.cancel();
      controller.close();
    };
    
    // Execute on platform thread
    executeOnPlatformThread<void>(() async {
      try {
        // Start the query
        subscription = queryStream().listen(
          (snapshot) {
            if (!controller.isClosed) {
              controller.add(snapshot);
            }
          },
          onError: (error) {
            debugPrint("Error in Firestore query: $error");
            if (!controller.isClosed) {
              controller.addError(error);
            }
          },
          onDone: () {
            if (!controller.isClosed) {
              controller.close();
            }
          },
        );
      } catch (e) {
        debugPrint("Error setting up Firestore query: $e");
        if (!controller.isClosed) {
          controller.addError(e);
          controller.close();
        }
      }
    });
    
    return controller.stream;
  }
  
  /// Execute a Firestore transaction safely on the platform thread.
  /// 
  /// Example usage:
  /// ```dart
  /// final result = await FirebaseThreadHandler.instance.executeTransaction((transaction) async {
  ///   final docSnapshot = await transaction.get(docRef);
  ///   // Perform transaction operations
  ///   return 'success';
  /// });
  /// ```
  Future<T> executeTransaction<T>(
    Future<T> Function(Transaction transaction) transactionFunction
  ) async {
    return executeOnPlatformThread(() {
      return FirebaseFirestore.instance.runTransaction(transactionFunction);
    });
  }
  
  /// Execute a Firestore batch write safely on the platform thread.
  /// 
  /// Example usage:
  /// ```dart
  /// await FirebaseThreadHandler.instance.executeBatch((batch) {
  ///   batch.set(doc1Ref, data1);
  ///   batch.update(doc2Ref, data2);
  ///   batch.delete(doc3Ref);
  /// });
  /// ```
  Future<void> executeBatch(void Function(WriteBatch batch) batchFunction) async {
    return executeOnPlatformThread(() async {
      final batch = FirebaseFirestore.instance.batch();
      batchFunction(batch);
      return batch.commit();
    });
  }
}

/// Serviciu pentru gestionarea formularelor √Æn Firebase Firestore
/// Acum folose»ôte noua structurƒÉ unificatƒÉ √Æn loc de colec»õia globalƒÉ 'forms'
class FirebaseFormService {
  static final FirebaseFormService _instance = FirebaseFormService._internal();
  factory FirebaseFormService() => _instance;
  FirebaseFormService._internal();

  final ClientsFirebaseService _clientService = ClientsFirebaseService();
  final FirebaseThreadHandler _threadHandler = FirebaseThreadHandler.instance;

  /// SalveazƒÉ datele formularului pentru un client √Æn noua structurƒÉ
  Future<bool> saveClientFormData({
    required String phoneNumber,
    required String clientName,
    required Map<String, dynamic> formData,
  }) async {
    try {
      debugPrint('üî• FirebaseFormService: Saving data to unified structure for client: $clientName ($phoneNumber)');
      debugPrint('üî• FirebaseFormService: Data structure: ${formData.keys.toList()}');
      
      await _threadHandler.executeOnPlatformThread(() async {
        // VerificƒÉ dacƒÉ clientul existƒÉ, dacƒÉ nu √Æl creeazƒÉ
        final existingClient = await _clientService.getClient(phoneNumber);
        if (existingClient == null) {
          await _clientService.createClient(
            phoneNumber: phoneNumber,
            name: clientName,
          );
        }

        // SalveazƒÉ datele formularului direct √Æn noua structurƒÉ
        await _clientService.saveClientForm(
          phoneNumber: phoneNumber,
          formType: 'unified_form',
          formData: formData,
        );
        
        debugPrint('‚úÖ FirebaseFormService: Successfully saved data to unified structure for client: $clientName');
      });
      return true;
    } catch (e) {
      debugPrint('‚ùå FirebaseFormService: Error saving form data to unified structure: $e');
      return false;
    }
  }

  /// √éncarcƒÉ datele formularului pentru un client din noua structurƒÉ
  Future<Map<String, dynamic>?> loadClientFormData(String phoneNumber) async {
    try {
      debugPrint('üî• FirebaseFormService: Loading data from unified structure for client: $phoneNumber');
      
      return await _threadHandler.executeOnPlatformThread(() async {
        final client = await _clientService.getClient(phoneNumber);
        
        if (client != null) {
          debugPrint('‚úÖ FirebaseFormService: Successfully loaded data from unified structure for client: $phoneNumber');
          
          // Obtine formularele clientului
          final forms = await _clientService.getClientForms(phoneNumber);
          final formData = forms.isNotEmpty ? forms.first['data'] ?? {} : {};
          
          return {
            'clientName': client.name,
            'phoneNumber': client.phoneNumber,
            'lastUpdated': DateTime.now().toIso8601String(),
            'formData': formData,
          };
        } else {
          debugPrint('‚ö†Ô∏è FirebaseFormService: No data found in unified structure for client: $phoneNumber');
        }
        return null;
      });
    } catch (e) {
      debugPrint('‚ùå FirebaseFormService: Error loading form data from unified structure: $e');
      return null;
    }
  }

  /// »òterge datele formularului pentru un client din noua structurƒÉ
  Future<bool> deleteClientFormData(String phoneNumber) async {
    try {
      await _threadHandler.executeOnPlatformThread(() async {
        // √én noua structurƒÉ, »ôtergem formularele clientului
        final forms = await _clientService.getClientForms(phoneNumber);
        for (final form in forms) {
          // Folosim NewFirebaseService pentru a »ôterge formularele
          final newFirebaseService = NewFirebaseService();
          await newFirebaseService.deleteClientForm(
            phoneNumber: phoneNumber,
            formId: form['id'] ?? form['formId'] ?? 'unified_form',
          );
        }
      });
      return true;
    } catch (e) {
      debugPrint('Error deleting form data from unified structure: $e');
      return false;
    }
  }

  /// SalveazƒÉ formularele de credit pentru un client
  Future<bool> saveCreditForms({
    required String phoneNumber,
    required String clientName,
    required List<Map<String, dynamic>> clientCreditForms,
    required List<Map<String, dynamic>> coborrowerCreditForms,
  }) async {
    final formData = {
      'creditForms': {
        'client': clientCreditForms,
        'coborrower': coborrowerCreditForms,
      }
    };

    return await saveClientFormData(
      phoneNumber: phoneNumber,
      clientName: clientName,
      formData: formData,
    );
  }

  /// SalveazƒÉ formularele de venit pentru un client
  Future<bool> saveIncomeForms({
    required String phoneNumber,
    required String clientName,
    required List<Map<String, dynamic>> clientIncomeForms,
    required List<Map<String, dynamic>> coborrowerIncomeForms,
  }) async {
    final formData = {
      'incomeForms': {
        'client': clientIncomeForms,
        'coborrower': coborrowerIncomeForms,
      }
    };

    return await saveClientFormData(
      phoneNumber: phoneNumber,
      clientName: clientName,
      formData: formData,
    );
  }

  /// SalveazƒÉ toate datele formularului pentru un client
  Future<bool> saveAllFormData({
    required String phoneNumber,
    required String clientName,
    required List<Map<String, dynamic>> clientCreditForms,
    required List<Map<String, dynamic>> coborrowerCreditForms,
    required List<Map<String, dynamic>> clientIncomeForms,
    required List<Map<String, dynamic>> coborrowerIncomeForms,
    required bool showingClientLoanForm,
    required bool showingClientIncomeForm,
  }) async {
    final formData = {
      'creditForms': {
        'client': clientCreditForms,
        'coborrower': coborrowerCreditForms,
      },
      'incomeForms': {
        'client': clientIncomeForms,
        'coborrower': coborrowerIncomeForms,
      },
      'showingClientLoanForm': showingClientLoanForm,
      'showingClientIncomeForm': showingClientIncomeForm,
    };

    return await saveClientFormData(
      phoneNumber: phoneNumber,
      clientName: clientName,
      formData: formData,
    );
  }

  /// √éncarcƒÉ toate datele formularului pentru un client
  Future<Map<String, dynamic>?> loadAllFormData(String phoneNumber) async {
    final data = await loadClientFormData(phoneNumber);
    return data?['formData'];
  }

  /// Ob»õine toate documentele din colec»õia forms (pentru debug/admin)
  /// Acum returneazƒÉ datele din noua structurƒÉ
  Future<List<Map<String, dynamic>>> getAllForms() async {
    try {
      return await _threadHandler.executeOnPlatformThread(() async {
        final clients = await _clientService.getAllClients();
        final List<Map<String, dynamic>> allForms = [];
        
        for (final client in clients) {
          final forms = await _clientService.getClientForms(client.phoneNumber);
          final formData = forms.isNotEmpty ? forms.first['data'] ?? {} : {};
          
          allForms.add({
            'id': client.phoneNumber,
            'clientName': client.name,
            'phoneNumber': client.phoneNumber,
            'lastUpdated': DateTime.now().toIso8601String(),
            'formData': formData,
          });
        }
        
        return allForms;
      });
    } catch (e) {
      debugPrint('Error getting all forms from unified structure: $e');
      return [];
    }
  }

  /// Stream pentru a asculta schimbƒÉrile √Æn timp real pentru un client
  Stream<Map<String, dynamic>?> streamClientFormData(String phoneNumber) {
    // Pentru compatibilitate, returnƒÉm un stream care emite periodic datele clientului
    return Stream.periodic(const Duration(seconds: 5)).asyncMap((_) async {
      final data = await loadClientFormData(phoneNumber);
      return data;
    });
  }


}

/// Serviciu Firebase refactorizat pentru noua structura
/// Separa corect datele pentru fiecare consultant
class NewFirebaseService {
  static final NewFirebaseService _instance = NewFirebaseService._internal();
  factory NewFirebaseService() => _instance;
  NewFirebaseService._internal();

  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final FirebaseThreadHandler _threadHandler = FirebaseThreadHandler.instance;

  // Collection names pentru noua structura
  static const String _consultantsCollection = 'consultants';
  static const String _clientsCollection = 'clients';
  static const String _statsCollection = 'stats';
  static const String _formsSubcollection = 'forms';
  static const String _meetingsSubcollection = 'meetings';

  User? get currentUser => _auth.currentUser;

  /// Obtine token-ul consultantului curent din baza de data
  Future<String?> getCurrentConsultantToken() async {
    final user = currentUser;
    debugPrint('üîç FIREBASE_SERVICE: getCurrentConsultantToken - currentUser: ${user?.email ?? 'NULL'}');
    
    if (user == null) {
      debugPrint('‚ùå FIREBASE_SERVICE: getCurrentConsultantToken - no current user');
      return null;
    }

    try {
      debugPrint('üîç FIREBASE_SERVICE: Fetching consultant document for UID: ${user.uid}');
      final doc = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_consultantsCollection).doc(user.uid).get()
      );
      
      if (doc.exists) {
        final token = doc.data()?['token'] as String?;
        debugPrint('üîç FIREBASE_SERVICE: Found consultant token: ${token != null ? '${token.substring(0, 8)}...' : 'NULL'}');
        return token;
      } else {
        debugPrint('‚ùå FIREBASE_SERVICE: Consultant document does not exist for UID: ${user.uid}');
        return null;
      }
    } catch (e) {
      debugPrint('‚ùå Error getting consultant token: $e');
      return null;
    }
  }

  /// Obtine datele consultantului pe baza token-ului
  Future<Map<String, dynamic>?> getConsultantByToken(String token) async {
    try {
      final snapshot = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_consultantsCollection)
            .where('token', isEqualTo: token)
            .limit(1)
            .get()
      );

      if (snapshot.docs.isNotEmpty) {
        return snapshot.docs.first.data();
      }
      return null;
    } catch (e) {
      debugPrint('‚ùå Error getting consultant by token: $e');
      return null;
    }
  }

  /// Obtine echipa consultantului curent
  Future<String?> getCurrentConsultantTeam() async {
    final token = await getCurrentConsultantToken();
    if (token == null) return null;

    final consultantData = await getConsultantByToken(token);
    return consultantData?['team'] as String?;
  }

  // =================== CLIENT OPERATIONS ===================

  /// Creeaza un client nou pentru consultantul curent
  Future<bool> createClient({
    required String phoneNumber,
    required String name,
    String? coDebitorName,
    String? status,
    String? category,
    Map<String, dynamic>? additionalData,
  }) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      final clientData = {
        'consultantToken': consultantToken,
        'name': name,
        'phoneNumber': phoneNumber,
        'coDebitorName': coDebitorName,
        'status': status ?? 'normal',
        'category': category ?? 'apeluri',
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
        ...?additionalData,
      };

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection).doc(phoneNumber).set(clientData)
      );

      debugPrint('‚úÖ Client created successfully: $name ($phoneNumber)');
      return true;
    } catch (e) {
      debugPrint('‚ùå Error creating client: $e');
      return false;
    }
  }

  /// Obtine un client dupa numarul de telefon (doar pentru consultantul curent)
  Future<Map<String, dynamic>?> getClient(String phoneNumber) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return null;

    try {
      final doc = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection).doc(phoneNumber).get()
      );

      final data = doc.data();
      if (data != null && data['consultantToken'] == consultantToken) {
        return data;
      }
      return null;
    } catch (e) {
      debugPrint('‚ùå Error getting client: $e');
      return null;
    }
  }

  /// Obtine toti clientii pentru consultantul curent (FIX: mai robust filtering)
  Future<List<Map<String, dynamic>>> getAllClients() async {
    final consultantToken = await getCurrentConsultantToken();
    debugPrint('üîç FIREBASE_SERVICE: getCurrentConsultantToken returned: ${consultantToken ?? 'NULL'}');
    
    if (consultantToken == null) {
      debugPrint('‚ùå FIREBASE_SERVICE: Cannot get clients - consultant token is null');
      return [];
    }

    try {
      debugPrint('üîç FIREBASE_SERVICE: Querying clients for token: ${consultantToken.substring(0, 8)}...');
      final snapshot = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .where('consultantToken', isEqualTo: consultantToken)
            .get()
      );

      debugPrint('üîç FIREBASE_SERVICE: Found ${snapshot.docs.length} clients for consultant');
      
      // FIX: verificƒÉ explicit cƒÉ consultantToken match-uie»ôte pentru fiecare client
      final clientsList = <Map<String, dynamic>>[];
      for (final doc in snapshot.docs) {
        final data = doc.data();
        final clientConsultantToken = data['consultantToken'] as String?;
        
        // Verificare explicitƒÉ pentru siguran»õƒÉ
        if (clientConsultantToken == consultantToken) {
          clientsList.add({
            'id': doc.id,
            ...data,
          });
        } else {
          debugPrint('‚ö†Ô∏è FIREBASE_SERVICE: Skipping client ${doc.id} - wrong consultant token');
        }
      }
      
      // Sortez local dupa updatedAt (descending)
      clientsList.sort((a, b) {
        final aTime = a['updatedAt'] as Timestamp?;
        final bTime = b['updatedAt'] as Timestamp?;
        
        if (aTime == null && bTime == null) return 0;
        if (aTime == null) return 1;
        if (bTime == null) return -1;
        
        return bTime.compareTo(aTime); // descending
      });
      
      debugPrint('‚úÖ FIREBASE_SERVICE: Returning ${clientsList.length} filtered clients');
      return clientsList;
    } catch (e) {
      debugPrint('‚ùå Error getting all clients: $e');
      return [];
    }
  }

  /// Actualizeaza un client
  Future<bool> updateClient(String phoneNumber, Map<String, dynamic> updates) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      updates['updatedAt'] = FieldValue.serverTimestamp();

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection).doc(phoneNumber).update(updates)
      );

      debugPrint('‚úÖ Client updated successfully: $phoneNumber');
      return true;
    } catch (e) {
      debugPrint('‚ùå Error updating client: $e');
      return false;
    }
  }

  /// Sterge un client si toate sub-colectiile sale
  Future<bool> deleteClient(String phoneNumber) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      final batch = _firestore.batch();
      final clientRef = _firestore.collection(_clientsCollection).doc(phoneNumber);

      // Sterge toate formularele
      final formsSnapshot = await clientRef.collection(_formsSubcollection).get();
      for (final doc in formsSnapshot.docs) {
        batch.delete(doc.reference);
      }

      // Sterge toate intalnirile
      final meetingsSnapshot = await clientRef.collection(_meetingsSubcollection).get();
      for (final doc in meetingsSnapshot.docs) {
        batch.delete(doc.reference);
      }

      // Sterge clientul
      batch.delete(clientRef);

      await _threadHandler.executeOnPlatformThread(() => batch.commit());

      debugPrint('‚úÖ Client deleted successfully: $phoneNumber');
      return true;
    } catch (e) {
      debugPrint('‚ùå Error deleting client: $e');
      return false;
    }
  }

  // =================== FORM OPERATIONS ===================

  /// Salveaza un formular pentru un client
  Future<bool> saveClientForm({
    required String phoneNumber,
    required String formId,
    required Map<String, dynamic> formData,
  }) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      final formDoc = {
        'formId': formId,
        'data': formData,
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      };

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_formsSubcollection)
            .doc(formId)
            .set(formDoc)
      );

      // Actualizeaza timestamp-ul clientului
      await updateClient(phoneNumber, {'updatedAt': FieldValue.serverTimestamp()});

      debugPrint('‚úÖ Form saved successfully: $formId for client $phoneNumber');
      return true;
    } catch (e) {
      debugPrint('‚ùå Error saving form: $e');
      return false;
    }
  }

  /// Obtine toate formularele pentru un client
  Future<List<Map<String, dynamic>>> getClientForms(String phoneNumber) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return [];

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return [];

      final snapshot = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_formsSubcollection)
            .orderBy('updatedAt', descending: true)
            .get()
      );

      return snapshot.docs.map((doc) => {
        'id': doc.id,
        ...doc.data(),
      }).toList();
    } catch (e) {
      debugPrint('‚ùå Error getting client forms: $e');
      return [];
    }
  }

  // =================== MEETING OPERATIONS ===================

  /// Creeaza o intalnire pentru un client
  Future<bool> createMeeting({
    required String phoneNumber,
    required DateTime dateTime,
    required String type,
    String? description,
    Map<String, dynamic>? additionalData,
  }) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      final meetingDoc = {
        'dateTime': Timestamp.fromDate(dateTime),
        'type': type,
        'description': description,
        'consultantToken': consultantToken,
        'consultantName': additionalData?['consultantName'] ?? 'Consultant necunoscut',
        'clientName': additionalData?['clientName'] ?? 'Client necunoscut',
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
        ...?additionalData,
      };

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_meetingsSubcollection)
            .add(meetingDoc)
      );

      // Actualizeaza timestamp-ul clientului
      await updateClient(phoneNumber, {'updatedAt': FieldValue.serverTimestamp()});

      debugPrint('‚úÖ Meeting created successfully for client $phoneNumber');
      return true;
    } catch (e) {
      debugPrint('‚ùå Error creating meeting: $e');
      return false;
    }
  }

  /// Obtine toate intalnirile pentru consultantul curent (FIX: mai robust filtering)
  Future<List<Map<String, dynamic>>> getAllMeetings() async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) {
      debugPrint('‚ùå FIREBASE_SERVICE: Cannot get meetings - consultant token is null');
      return [];
    }

    try {
      debugPrint('üîç FIREBASE_SERVICE: Getting meetings for consultant: ${consultantToken.substring(0, 8)}...');
      final clients = await getAllClients(); // Folose»ôte getAllClients care deja filtreazƒÉ corect
      final List<Map<String, dynamic>> allMeetings = [];

      debugPrint('üîç FIREBASE_SERVICE: Processing ${clients.length} clients for meetings');

      for (final client in clients) {
        final phoneNumber = client['phoneNumber'] as String;
        
        // Verificare suplimentarƒÉ pentru siguran»õƒÉ
        if (client['consultantToken'] != consultantToken) {
          debugPrint('‚ö†Ô∏è FIREBASE_SERVICE: Skipping client $phoneNumber - wrong consultant token');
          continue;
        }
        
        final meetingsSnapshot = await _threadHandler.executeOnPlatformThread(() =>
          _firestore.collection(_clientsCollection)
              .doc(phoneNumber)
              .collection(_meetingsSubcollection)
              .orderBy('dateTime', descending: false)
              .get()
        );

        debugPrint('üîç FIREBASE_SERVICE: Found ${meetingsSnapshot.docs.length} meetings for client $phoneNumber');

        for (final doc in meetingsSnapshot.docs) {
          // FIX: AsigurƒÉ-te cƒÉ consultantToken este disponibil pentru identificare
          final meetingData = doc.data();
          final additionalData = meetingData['additionalData'] as Map<String, dynamic>? ?? {};
          
          allMeetings.add({
            'id': doc.id,
            'clientPhoneNumber': phoneNumber,
            'clientName': client['name'],
            'consultantToken': consultantToken, // FIX: asigurƒÉ-te cƒÉ este setat corect
            ...meetingData,
            'additionalData': {
              ...additionalData,
              'consultantToken': consultantToken, // FIX: Folose»ôte token-ul pentru identificare
            },
          });
        }
      }

      debugPrint('‚úÖ FIREBASE_SERVICE: Returning ${allMeetings.length} total meetings for consultant');
      return allMeetings;
    } catch (e) {
      debugPrint('‚ùå Error getting all meetings: $e');
      return [];
    }
  }

  /// Obtine intalnirile pentru echipa consultantului curent (FIX: mai robust filtering)
  Future<List<Map<String, dynamic>>> getTeamMeetings() async {
    final team = await getCurrentConsultantTeam();
    if (team == null) {
      debugPrint('‚ùå FIREBASE_SERVICE: Cannot get team meetings - team is null');
      return [];
    }

    try {
      debugPrint('üîç FIREBASE_SERVICE: Getting team meetings for team: $team');
      
      // Obtine toti consultantii din echipa
      final teamConsultantsSnapshot = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_consultantsCollection)
            .where('team', isEqualTo: team)
            .get()
      );

      final List<String> teamTokens = teamConsultantsSnapshot.docs
          .map((doc) => doc.data()['token'] as String)
          .where((token) => token.isNotEmpty)
          .toList();
      debugPrint('üîç FIREBASE_SERVICE: Found ${teamTokens.length} consultants in team $team');

      // Obtine clientii pentru toti consultantii din echipa
      final List<Map<String, dynamic>> teamMeetings = [];
      
      for (final token in teamTokens) {
        debugPrint('üîç FIREBASE_SERVICE: Processing meetings for consultant token: ${token.substring(0, 8)}...');
        
        final clientsSnapshot = await _threadHandler.executeOnPlatformThread(() =>
          _firestore.collection(_clientsCollection)
              .where('consultantToken', isEqualTo: token)
              .get()
        );

        debugPrint('üîç FIREBASE_SERVICE: Found ${clientsSnapshot.docs.length} clients for consultant');

        for (final clientDoc in clientsSnapshot.docs) {
          final phoneNumber = clientDoc.id;
          final clientData = clientDoc.data();
          
          // FIX: verificare suplimentarƒÉ pentru siguran»õƒÉ
          if (clientData['consultantToken'] != token) {
            debugPrint('‚ö†Ô∏è FIREBASE_SERVICE: Skipping client $phoneNumber - token mismatch');
            continue;
          }
          
          final meetingsSnapshot = await _threadHandler.executeOnPlatformThread(() =>
            _firestore.collection(_clientsCollection)
                .doc(phoneNumber)
                .collection(_meetingsSubcollection)
                .orderBy('dateTime', descending: false)
                .get()
          );

          for (final meetingDoc in meetingsSnapshot.docs) {
            // FIX: AsigurƒÉ-te cƒÉ consultantToken este disponibil pentru identificare
            final meetingData = meetingDoc.data();
            final additionalData = meetingData['additionalData'] as Map<String, dynamic>? ?? {};
            
            teamMeetings.add({
              'id': meetingDoc.id,
              'clientPhoneNumber': phoneNumber,
              'clientName': clientData['name'],
              'consultantToken': token, // FIX: asigurƒÉ-te cƒÉ este setat corect
              ...meetingData,
              'additionalData': {
                ...additionalData,
                'consultantToken': token, // FIX: Folose»ôte token-ul pentru identificare √Æn calendar
              },
            });
          }
        }
      }

      debugPrint('‚úÖ FIREBASE_SERVICE: Returning ${teamMeetings.length} total team meetings');
      return teamMeetings;
    } catch (e) {
      debugPrint('‚ùå Error getting team meetings: $e');
      return [];
    }
  }

  /// Actualizeaza o intalnire existenta
  Future<bool> updateMeeting({
    required String phoneNumber,
    required String meetingId,
    DateTime? dateTime,
    String? type,
    String? description,
    Map<String, dynamic>? additionalData,
  }) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      final updates = <String, dynamic>{
        'updatedAt': FieldValue.serverTimestamp(),
      };

      if (dateTime != null) updates['dateTime'] = Timestamp.fromDate(dateTime);
      if (type != null) updates['type'] = type;
      if (description != null) updates['description'] = description;
      if (additionalData != null) updates['additionalData'] = additionalData;

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_meetingsSubcollection)
            .doc(meetingId)
            .update(updates)
      );

      // Actualizeaza timestamp-ul clientului
      await updateClient(phoneNumber, {'updatedAt': FieldValue.serverTimestamp()});

      debugPrint('‚úÖ Meeting updated successfully: $meetingId for client $phoneNumber');
      return true;
    } catch (e) {
      debugPrint('‚ùå Error updating meeting: $e');
      return false;
    }
  }

  /// Sterge o intalnire specifica
  Future<bool> deleteMeeting({
    required String phoneNumber,
    required String meetingId,
  }) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_meetingsSubcollection)
            .doc(meetingId)
            .delete()
      );

      // Actualizeaza timestamp-ul clientului
      await updateClient(phoneNumber, {'updatedAt': FieldValue.serverTimestamp()});

      debugPrint('‚úÖ Meeting deleted successfully: $meetingId for client $phoneNumber');
      return true;
    } catch (e) {
      debugPrint('‚ùå Error deleting meeting: $e');
      return false;
    }
  }

  /// Sterge un formular specific
  Future<bool> deleteClientForm({
    required String phoneNumber,
    required String formId,
  }) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_formsSubcollection)
            .doc(formId)
            .delete()
      );

      // Actualizeaza timestamp-ul clientului
      await updateClient(phoneNumber, {'updatedAt': FieldValue.serverTimestamp()});

      debugPrint('‚úÖ Form deleted successfully: $formId for client $phoneNumber');
      return true;
    } catch (e) {
      debugPrint('‚ùå Error deleting form: $e');
      return false;
    }
  }

  // =================== STATS OPERATIONS ===================

  /// Actualizeaza statistici globale
  Future<bool> updateGlobalStats(Map<String, dynamic> stats) async {
    try {
      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_statsCollection).doc('global').set(stats, SetOptions(merge: true))
      );
      return true;
    } catch (e) {
      debugPrint('‚ùå Error updating global stats: $e');
      return false;
    }
  }

  /// Obtine statistici globale
  Future<Map<String, dynamic>?> getGlobalStats() async {
    try {
      final doc = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_statsCollection).doc('global').get()
      );
      return doc.data();
    } catch (e) {
      debugPrint('‚ùå Error getting global stats: $e');
      return null;
    }
  }

  /// Actualizeaza statistici pentru o echipa
  Future<bool> updateTeamStats(String teamName, Map<String, dynamic> stats) async {
    try {
      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_statsCollection).doc('teams').collection(teamName).doc('stats').set(stats, SetOptions(merge: true))
      );
      return true;
    } catch (e) {
      debugPrint('‚ùå Error updating team stats: $e');
      return false;
    }
  }

  // =================== MIGRATION HELPERS ===================

  /// Migreaza datele existente la noua structura
  Future<bool> migrateToNewStructure() async {
    try {
      debugPrint('üîÑ Starting migration to new structure...');
      
      // Aceasta functie va fi implementata pentru a migra datele existente
      // Dar pentru simplitate, vom incepe cu o structura curata
      
      debugPrint('‚úÖ Migration completed successfully');
      return true;
    } catch (e) {
      debugPrint('‚ùå Error during migration: $e');
      return false;
    }
  }

  /// Curata structura existenta (ATENTIE: Sterge toate datele!)
  Future<bool> clearOldStructure() async {
    try {
      debugPrint('üîÑ Starting cleanup of old structure...');
      
      // ATENTIE: Aceasta functie va sterge toate datele din structura veche!
      // Foloseste-o doar dupa ce ai migrat datele necesare
      
      debugPrint('‚ö†Ô∏è Cleanup functionality not implemented for safety');
      debugPrint('‚úÖ Cleanup completed successfully');
      return true;
    } catch (e) {
      debugPrint('‚ùå Error during cleanup: $e');
      return false;
    }
  }
}

/// Serviciu pentru migrarea datelor la noua structura Firebase
class MigrationService {
  static final MigrationService _instance = MigrationService._internal();
  factory MigrationService() => _instance;
  MigrationService._internal();

  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  /// Incepe migrarea completa la noua structura
  Future<Map<String, dynamic>> startMigration() async {
    try {
      debugPrint('üîÑ MIGRATION: Starting complete migration to new structure...');

      // Pasul 1: Migreaza consultantii
      final consultantsResult = await _migrateConsultants();
      if (!consultantsResult['success']) {
        return consultantsResult;
      }

      // Pasul 2: Migreaza clientii si datele asociate
      final clientsResult = await _migrateClients();
      if (!clientsResult['success']) {
        return clientsResult;
      }

      // Pasul 3: Creeaza structura pentru statistici
      await _createStatsStructure();

      debugPrint('‚úÖ MIGRATION: Complete migration finished successfully');
      return {
        'success': true,
        'message': 'Migrarea s-a finalizat cu succes',
        'consultantsMigrated': consultantsResult['count'],
        'clientsMigrated': clientsResult['count'],
      };
    } catch (e) {
      debugPrint('‚ùå MIGRATION: Error during migration: $e');
      return {
        'success': false,
        'message': 'Eroare √Æn timpul migrƒÉrii: $e',
      };
    }
  }

  /// Migreaza consultantii la noua structura
  Future<Map<String, dynamic>> _migrateConsultants() async {
    try {
      debugPrint('üîÑ MIGRATION: Migrating consultants...');
      
      // Obtine toti consultantii din structura veche
      final oldConsultantsSnapshot = await _firestore.collection('consultants').get();
      int migratedCount = 0;

      for (final doc in oldConsultantsSnapshot.docs) {
        final data = doc.data();
        
        // Verifica daca consultantul are deja token
        if (data.containsKey('token')) {
          debugPrint('‚úÖ MIGRATION: Consultant ${data['name']} already has token');
          migratedCount++;
        } else {
          debugPrint('‚ö†Ô∏è MIGRATION: Consultant ${data['name']} needs token update');
          // Aici ai putea adauga logica pentru a genera token-uri pentru consultantii existenti
        }
      }

      debugPrint('‚úÖ MIGRATION: Migrated $migratedCount consultants');
      return {
        'success': true,
        'count': migratedCount,
      };
    } catch (e) {
      debugPrint('‚ùå MIGRATION: Error migrating consultants: $e');
      return {
        'success': false,
        'message': 'Eroare la migrarea consultantilor: $e',
      };
    }
  }

  /// Migreaza clientii la noua structura
  Future<Map<String, dynamic>> _migrateClients() async {
    try {
      debugPrint('üîÑ MIGRATION: Migrating clients to new structure...');
      
      // Pentru noua structura, clientii vor fi creati direct cu noua structura
      // Datele vechi pot fi pastrate pentru backup sau migrate manual
      
      debugPrint('‚úÖ MIGRATION: Client migration prepared (will use new structure)');
      return {
        'success': true,
        'count': 0, // Clientii vor fi creati fresh cu noua structura
      };
    } catch (e) {
      debugPrint('‚ùå MIGRATION: Error preparing client migration: $e');
      return {
        'success': false,
        'message': 'Eroare la migrarea clientilor: $e',
      };
    }
  }

  /// Creeaza structura pentru statistici
  Future<void> _createStatsStructure() async {
    try {
      debugPrint('üîÑ MIGRATION: Creating stats structure...');
      
      // Creeaza document global pentru statistici
      await _firestore.collection('stats').doc('global').set({
        'totalClients': 0,
        'totalMeetings': 0,
        'dutyAgent': '',
        'dutyRotation': [],
        'lastUpdated': FieldValue.serverTimestamp(),
        'createdAt': FieldValue.serverTimestamp(),
      });

      debugPrint('‚úÖ MIGRATION: Stats structure created');
    } catch (e) {
      debugPrint('‚ùå MIGRATION: Error creating stats structure: $e');
    }
  }

  /// Verifica daca migrarea este necesara
  Future<bool> isMigrationNeeded() async {
    try {
      // Verifica daca exista structura noua
      final globalStatsDoc = await _firestore.collection('stats').doc('global').get();
      return !globalStatsDoc.exists;
    } catch (e) {
      debugPrint('‚ùå MIGRATION: Error checking migration status: $e');
      return true; // Pe siguranta, presupunem ca migrarea este necesara
    }
  }
}



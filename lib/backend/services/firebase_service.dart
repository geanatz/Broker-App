// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;
import 'clients_service.dart';
import 'package:firebase_auth/firebase_auth.dart';

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'backend/services/firebaseService.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyBmkOMU2YvyJyCa72Lm1D3i62xS9uVISvY',
    appId: '1:324961203074:web:aebb2c8a1fbdd12307559b',
    messagingSenderId: '324961203074',
    projectId: 'broker-app-f1n4nc3',
    authDomain: 'broker-app-f1n4nc3.firebaseapp.com',
    storageBucket: 'broker-app-f1n4nc3.firebasestorage.app',
    measurementId: 'G-RQYQ68D69W',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCr0N-3rXc_KNz5nxM4JG9cCbNLsm8rFu8',
    appId: '1:324961203074:android:a49e09c8f2d20d6807559b',
    messagingSenderId: '324961203074',
    projectId: 'broker-app-f1n4nc3',
    storageBucket: 'broker-app-f1n4nc3.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyAMxDPWmCbHRXL9qhuNxDFzY7f8IY1oHtA',
    appId: '1:324961203074:ios:7f8c65d4099a996207559b',
    messagingSenderId: '324961203074',
    projectId: 'broker-app-f1n4nc3',
    storageBucket: 'broker-app-f1n4nc3.firebasestorage.app',
    iosBundleId: 'com.example.brokerApp',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyAMxDPWmCbHRXL9qhuNxDFzY7f8IY1oHtA',
    appId: '1:324961203074:ios:7f8c65d4099a996207559b',
    messagingSenderId: '324961203074',
    projectId: 'broker-app-f1n4nc3',
    storageBucket: 'broker-app-f1n4nc3.firebasestorage.app',
    iosBundleId: 'com.example.brokerApp',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyBmkOMU2YvyJyCa72Lm1D3i62xS9uVISvY',
    appId: '1:324961203074:web:d67064b2b9ae146707559b',
    messagingSenderId: '324961203074',
    projectId: 'broker-app-f1n4nc3',
    authDomain: 'broker-app-f1n4nc3.firebaseapp.com',
    storageBucket: 'broker-app-f1n4nc3.firebasestorage.app',
    measurementId: 'G-NKE39RD50B',
  );
}

/// Performance monitoring utility
class PerformanceMonitor {
  static final Map<String, Stopwatch> _timers = {};
  static final Map<String, List<int>> _metrics = {};
  
  static void startTimer(String operation) {
    _timers[operation] = Stopwatch()..start();
  }
  
  static void endTimer(String operation) {
    final timer = _timers[operation];
    if (timer != null) {
      timer.stop();
      final duration = timer.elapsedMilliseconds;
      _metrics.putIfAbsent(operation, () => []).add(duration);
      _timers.remove(operation);
    }
  }
  
  static void logMetric(String operation, int duration) {
    _metrics.putIfAbsent(operation, () => []).add(duration);
  }
  
  static Map<String, double> getAverageMetrics() {
    final averages = <String, double>{};
    _metrics.forEach((operation, durations) {
      if (durations.isNotEmpty) {
        averages[operation] = durations.reduce((a, b) => a + b) / durations.length;
      }
    });
    return averages;
  }
  
  static void printPerformanceReport() {
    final averages = getAverageMetrics();
    debugPrint('[PERF] PERFORMANCE REPORT:');
    averages.forEach((operation, avgTime) {
      debugPrint('  $operation: ${avgTime.toStringAsFixed(2)}ms avg');
    });
  }
  
  /// Prints a comprehensive performance summary
  static void printComprehensiveReport() {
    final averages = getAverageMetrics();
    debugPrint('[PERF] COMPREHENSIVE PERFORMANCE REPORT:');
    debugPrint('=====================================');
    
    // Sort by average time (slowest first)
    final sortedMetrics = averages.entries.toList()
      ..sort((a, b) => b.value.compareTo(a.value));
    
    for (final entry in sortedMetrics) {
      final operation = entry.key;
      final avgTime = entry.value;
      final emoji = avgTime > 1000 ? 'üêå' : avgTime > 500 ? '‚ö†Ô∏è' : '‚ö°';
      debugPrint('$emoji $operation: ${avgTime.toStringAsFixed(2)}ms avg');
    }
    
    debugPrint('=====================================');
    debugPrint('Total operations tracked: ${_metrics.length}');
    debugPrint('Active timers: ${_timers.length}');
  }
}

class FirebaseThreadHandler {

  FirebaseThreadHandler._();

  static final FirebaseThreadHandler instance = FirebaseThreadHandler._();

  Future<T> executeOnPlatformThread<T>(Future<T> Function() operation) async {
    final completer = Completer<T>();
    
    void runOperation() async {
      try {
        final result = await operation();
        if (!completer.isCompleted) {
          completer.complete(result);
        }
      } catch (e) {
        debugPrint('Error in Firebase operation: $e');
        if (!completer.isCompleted) {
          completer.completeError(e);
        }
      }
    }
    
    // Detect if we're already on the platform thread
    if (WidgetsBinding.instance.rootElement == null) {
      // Not on platform thread, schedule the operation for the next frame
      WidgetsBinding.instance.addPostFrameCallback((_) => runOperation());
    } else {
      // Already on platform thread, execute immediately
      runOperation();
    }
    
    return completer.future;
  }
  
  Stream<QuerySnapshot> createSafeQueryStream(Stream<QuerySnapshot> Function() queryStream) {
    // Create a stream controller that will be responsible for the stream management
    final controller = StreamController<QuerySnapshot>.broadcast();
    
    // Set up proper cancellation handler
    StreamSubscription? subscription;
    controller.onCancel = () {
      subscription?.cancel();
      controller.close();
    };
    
    // Execute on platform thread
    executeOnPlatformThread<void>(() async {
      try {
        // Start the query
        subscription = queryStream().listen(
          (snapshot) {
            if (!controller.isClosed) {
              controller.add(snapshot);
            }
          },
          onError: (error) {
            debugPrint("Error in Firestore query: $error");
            if (!controller.isClosed) {
              controller.addError(error);
            }
          },
          onDone: () {
            if (!controller.isClosed) {
              controller.close();
            }
          },
        );
      } catch (e) {
        debugPrint("Error setting up Firestore query: $e");
        if (!controller.isClosed) {
          controller.addError(e);
          controller.close();
        }
      }
    });
    
    return controller.stream;
  }
  
  Future<T> executeTransaction<T>(
    Future<T> Function(Transaction transaction) transactionFunction
  ) async {
    return executeOnPlatformThread(() {
      return FirebaseFirestore.instance.runTransaction(transactionFunction);
    });
  }
  
  Future<void> executeBatch(void Function(WriteBatch batch) batchFunction) async {
    return executeOnPlatformThread(() async {
      final batch = FirebaseFirestore.instance.batch();
      batchFunction(batch);
      return batch.commit();
    });
  }
}

/// Serviciu pentru gestionarea formularelor √Æn Firebase Firestore
class FirebaseFormService {
  static final FirebaseFormService _instance = FirebaseFormService._internal();
  factory FirebaseFormService() => _instance;
  FirebaseFormService._internal();

  final ClientsFirebaseService _clientService = ClientsFirebaseService();
  final FirebaseThreadHandler _threadHandler = FirebaseThreadHandler.instance;

  /// SalveazƒÉ datele formularului pentru un client
  Future<bool> saveClientFormData({
    required String phoneNumber,
    required String clientName,
    required Map<String, dynamic> formData,
  }) async {
    try {
      await _threadHandler.executeOnPlatformThread(() async {
        // VerificƒÉ dacƒÉ clientul existƒÉ, dacƒÉ nu √Æl creeazƒÉ
        final existingClient = await _clientService.getClient(phoneNumber);
        if (existingClient == null) {
          // FIX: Nu crea automat clientul dacƒÉ nu existƒÉ - lasƒÉ aplica»õia sƒÉ gestioneze crearea
          debugPrint('‚ö†Ô∏è FIREBASE_SERVICE: Skipping automatic client creation for: $phoneNumber');
          return;
        }

        // SalveazƒÉ datele formularului direct √Æn noua structurƒÉ
        await _clientService.saveClientForm(
          phoneNumber: phoneNumber,
          formType: 'unified_form',
          formData: formData,
        );
      });
      return true;
    } catch (e) {
      debugPrint('‚ùå FirebaseFormService: Error saving form data: $e');
      return false;
    }
  }

  /// √éncarcƒÉ datele formularului pentru un client din noua structurƒÉ
  Future<Map<String, dynamic>?> loadClientFormData(String phoneNumber) async {
    try {
      return await _threadHandler.executeOnPlatformThread(() async {
        final client = await _clientService.getClient(phoneNumber);
        
        if (client != null) {
          // Obtine formularele clientului
          final forms = await _clientService.getClientForms(phoneNumber);
          final formData = forms.isNotEmpty ? forms.first['data'] ?? {} : {};
          
          return {
            'clientName': client.name,
            'phoneNumber': client.phoneNumber,
            'lastUpdated': DateTime.now().toIso8601String(),
            'formData': formData,
          };
        }
        return null;
      });
    } catch (e) {
      debugPrint('‚ùå FirebaseFormService: Error loading form data: $e');
      return null;
    }
  }

  /// »òterge datele formularului pentru un client din noua structurƒÉ
  Future<bool> deleteClientFormData(String phoneNumber) async {
    try {
      await _threadHandler.executeOnPlatformThread(() async {
        final forms = await _clientService.getClientForms(phoneNumber);
        for (final form in forms) {
          final newFirebaseService = NewFirebaseService();
          await newFirebaseService.deleteClientForm(
            phoneNumber: phoneNumber,
            formId: form['id'] ?? form['formId'] ?? 'unified_form',
          );
        }
      });
      return true;
    } catch (e) {
      debugPrint('Error deleting form data from unified structure: $e');
      return false;
    }
  }

  /// SalveazƒÉ formularele de credit pentru un client
  Future<bool> saveCreditForms({
    required String phoneNumber,
    required String clientName,
    required List<Map<String, dynamic>> clientCreditForms,
    required List<Map<String, dynamic>> coborrowerCreditForms,
  }) async {
    final formData = {
      'creditForms': {
        'client': clientCreditForms,
        'coborrower': coborrowerCreditForms,
      }
    };

    return await saveClientFormData(
      phoneNumber: phoneNumber,
      clientName: clientName,
      formData: formData,
    );
  }

  /// SalveazƒÉ formularele de venit pentru un client
  Future<bool> saveIncomeForms({
    required String phoneNumber,
    required String clientName,
    required List<Map<String, dynamic>> clientIncomeForms,
    required List<Map<String, dynamic>> coborrowerIncomeForms,
  }) async {
    final formData = {
      'incomeForms': {
        'client': clientIncomeForms,
        'coborrower': coborrowerIncomeForms,
      }
    };

    return await saveClientFormData(
      phoneNumber: phoneNumber,
      clientName: clientName,
      formData: formData,
    );
  }

  /// SalveazƒÉ toate datele formularului pentru un client
  Future<bool> saveAllFormData({
    required String phoneNumber,
    required String clientName,
    required List<Map<String, dynamic>> clientCreditForms,
    required List<Map<String, dynamic>> coborrowerCreditForms,
    required List<Map<String, dynamic>> clientIncomeForms,
    required List<Map<String, dynamic>> coborrowerIncomeForms,
    required bool showingClientLoanForm,
    required bool showingClientIncomeForm,
  }) async {
    final formData = {
      'creditForms': {
        'client': clientCreditForms,
        'coborrower': coborrowerCreditForms,
      },
      'incomeForms': {
        'client': clientIncomeForms,
        'coborrower': coborrowerIncomeForms,
      },
      'showingClientLoanForm': showingClientLoanForm,
      'showingClientIncomeForm': showingClientIncomeForm,
    };

    return await saveClientFormData(
      phoneNumber: phoneNumber,
      clientName: clientName,
      formData: formData,
    );
  }

  /// √éncarcƒÉ toate datele formularului pentru un client
  Future<Map<String, dynamic>?> loadAllFormData(String phoneNumber) async {
    try {
      final data = await loadClientFormData(phoneNumber);
      if (data == null) return null;
      
      final formData = data['formData'];
      if (formData == null) return null;
      
      // Ensure type safety by converting dynamic to Map<String, dynamic>
      if (formData is Map) {
        return Map<String, dynamic>.from(formData);
      }
      
      return null;
    } catch (e) {
      debugPrint('‚ùå FirebaseFormService: Error in loadAllFormData: $e');
      return null;
    }
  }

  /// Ob»õine toate documentele din colec»õia forms (pentru debug/admin)
  Future<List<Map<String, dynamic>>> getAllForms() async {
    try {
      return await _threadHandler.executeOnPlatformThread(() async {
        final clients = await _clientService.getAllClients();
        final List<Map<String, dynamic>> allForms = [];
        
        for (final client in clients) {
          final forms = await _clientService.getClientForms(client.phoneNumber);
          final formData = forms.isNotEmpty ? forms.first['data'] ?? {} : {};
          
          allForms.add({
            'id': client.phoneNumber,
            'clientName': client.name,
            'phoneNumber': client.phoneNumber,
            'lastUpdated': DateTime.now().toIso8601String(),
            'formData': formData,
          });
        }
        
        return allForms;
      });
    } catch (e) {
      debugPrint('Error getting all forms from unified structure: $e');
      return [];
    }
  }

  /// Stream pentru a asculta schimbƒÉrile √Æn timp real pentru un client
  Stream<Map<String, dynamic>?> streamClientFormData(String phoneNumber) {
    // Pentru compatibilitate, returnƒÉm un stream care emite periodic datele clientului
    return Stream.periodic(const Duration(seconds: 5)).asyncMap((_) async {
      final data = await loadClientFormData(phoneNumber);
      return data;
    });
  }


}

/// Serviciu Firebase refactorizat pentru noua structura
class NewFirebaseService {
  static final NewFirebaseService _instance = NewFirebaseService._internal();
  factory NewFirebaseService() => _instance;
  NewFirebaseService._internal();

  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final FirebaseThreadHandler _threadHandler = FirebaseThreadHandler.instance;

  // Collection names pentru noua structura
  static const String _consultantsCollection = 'consultants';
  static const String _clientsCollection = 'clients';
  static const String _statsCollection = 'stats';
  static const String _formsSubcollection = 'forms';
  static const String _meetingsSubcollection = 'meetings';

  User? get currentUser => _auth.currentUser;

  // Cache pentru token-ul consultantului
  String? _cachedConsultantToken;
  DateTime? _tokenCacheTime;
  static const Duration _tokenCacheDuration = Duration(minutes: 5);

  /// Obtine token-ul consultantului curent din baza de data (cu cache)
  Future<String?> getCurrentConsultantToken() async {
    PerformanceMonitor.startTimer('getCurrentConsultantToken');
    
    // Verifica cache-ul
    if (_cachedConsultantToken != null && _tokenCacheTime != null) {
      final cacheAge = DateTime.now().difference(_tokenCacheTime!);
      if (cacheAge < _tokenCacheDuration) {
        // Log cache usage with reduced frequency
        if (cacheAge.inMilliseconds % 1000 < 100) { // Log only every ~1 second
          debugPrint('üöÄ FIREBASE_SERVICE: Using cached consultant token (age: ${cacheAge.inMilliseconds}ms)');
        }
        PerformanceMonitor.endTimer('getCurrentConsultantToken');
        return _cachedConsultantToken;
      }
    }
    
    debugPrint('üîç FIREBASE_SERVICE: getCurrentConsultantToken called');
    
    final user = currentUser;
    debugPrint('üîç FIREBASE_SERVICE: getCurrentConsultantToken currentUser = ${user?.uid}');
    if (user == null) {
      debugPrint('‚ùå FIREBASE_SERVICE: getCurrentConsultantToken currentUser is null');
      PerformanceMonitor.endTimer('getCurrentConsultantToken');
      return null;
    }

    try {
      debugPrint('üîç FIREBASE_SERVICE: getCurrentConsultantToken fetching consultant document');
      final doc = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_consultantsCollection).doc(user.uid).get()
      );
      
      debugPrint('üîç FIREBASE_SERVICE: getCurrentConsultantToken document exists = ${doc.exists}');
      
      if (doc.exists) {
        final data = doc.data();
        debugPrint('üîç FIREBASE_SERVICE: getCurrentConsultantToken document data = $data');
        
        final token = data?['token'] as String?;
        debugPrint('üîç FIREBASE_SERVICE: getCurrentConsultantToken token = "$token"');
        
        if (token == null || token.isEmpty) {
          debugPrint('‚ùå FIREBASE_SERVICE: getCurrentConsultantToken token is null or empty');
          PerformanceMonitor.endTimer('getCurrentConsultantToken');
          return null;
        } else {
          debugPrint('‚úÖ FIREBASE_SERVICE: getCurrentConsultantToken returning token');
          
          // Salveaza in cache
          _cachedConsultantToken = token;
          _tokenCacheTime = DateTime.now();
          debugPrint('üíæ FIREBASE_SERVICE: Cached consultant token');
          
          PerformanceMonitor.endTimer('getCurrentConsultantToken');
          return token;
        }
      } else {
        debugPrint('‚ùå FIREBASE_SERVICE: Consultant document does not exist for UID: ${user.uid}');
        PerformanceMonitor.endTimer('getCurrentConsultantToken');
        return null;
      }
    } catch (e) {
      debugPrint('‚ùå FIREBASE_SERVICE: Error getting consultant token: $e');
      debugPrint('‚ùå FIREBASE_SERVICE: getCurrentConsultantToken stack trace: ${StackTrace.current}');
      PerformanceMonitor.endTimer('getCurrentConsultantToken');
      return null;
    }
  }

  /// Invalideaza cache-ul pentru token-ul consultantului
  void invalidateConsultantTokenCache() {
    _cachedConsultantToken = null;
    _tokenCacheTime = null;
    debugPrint('üóëÔ∏è FIREBASE_SERVICE: Invalidated consultant token cache');
  }

  /// Obtine datele consultantului pe baza token-ului
  Future<Map<String, dynamic>?> getConsultantByToken(String token) async {
    try {
      final snapshot = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_consultantsCollection)
            .where('token', isEqualTo: token)
            .limit(1)
            .get()
      );

      if (snapshot.docs.isNotEmpty) {
        return snapshot.docs.first.data();
      }
      return null;
    } catch (e) {
      debugPrint('‚ùå Error getting consultant by token: $e');
      return null;
    }
  }

  /// Obtine echipa consultantului curent
  Future<String?> getCurrentConsultantTeam() async {
    final token = await getCurrentConsultantToken();
    if (token == null) return null;

    final consultantData = await getConsultantByToken(token);
    return consultantData?['team'] as String?;
  }

  // =================== CLIENT OPERATIONS ===================

  /// Creeaza un client nou pentru consultantul curent
  Future<bool> createClient({
    required String phoneNumber,
    required String name,
    String? coDebitorName,
    String? status,
    String? category,
    Map<String, dynamic>? additionalData,
  }) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      final clientData = {
        'consultantToken': consultantToken,
        'name': name,
        'phoneNumber': phoneNumber,
        'coDebitorName': coDebitorName,
        'status': status ?? 'normal',
        'category': category ?? 'apeluri',
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
        ...?additionalData,
      };

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection).doc(phoneNumber).set(clientData)
      );
      return true;
    } catch (e) {
      debugPrint('‚ùå Error creating client: $e');
      return false;
    }
  }

  /// Obtine un client dupa numarul de telefon (doar pentru consultantul curent)
  Future<Map<String, dynamic>?> getClient(String phoneNumber) async {
    debugPrint('üîç FIREBASE_SERVICE: getClient called with phoneNumber = "$phoneNumber"');
    
    final consultantToken = await getCurrentConsultantToken();
    debugPrint('üîç FIREBASE_SERVICE: getClient consultantToken = "$consultantToken"');
    if (consultantToken == null) {
      debugPrint('‚ùå FIREBASE_SERVICE: getClient consultantToken is null');
      return null;
    }

    try {
      debugPrint('üîç FIREBASE_SERVICE: getClient fetching document from Firestore');
      final doc = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection).doc(phoneNumber).get()
      );

      final data = doc.data();
      debugPrint('üîç FIREBASE_SERVICE: getClient document data = $data');
      
      if (data != null && data['consultantToken'] == consultantToken) {
        debugPrint('‚úÖ FIREBASE_SERVICE: getClient found matching client');
        return data;
      } else {
        debugPrint('‚ùå FIREBASE_SERVICE: getClient no matching client found');
        if (data != null) {
          debugPrint('üîç FIREBASE_SERVICE: getClient data consultantToken = "${data['consultantToken']}"');
          debugPrint('üîç FIREBASE_SERVICE: getClient expected consultantToken = "$consultantToken"');
        }
      }
      return null;
    } catch (e) {
      debugPrint('‚ùå FIREBASE_SERVICE: getClient error: $e');
      debugPrint('‚ùå FIREBASE_SERVICE: getClient stack trace: ${StackTrace.current}');
      return null;
    }
  }

  /// Obtine toti clientii pentru consultantul curent (FIX: mai robust filtering)
  Future<List<Map<String, dynamic>>> getAllClients() async {
    final consultantToken = await getCurrentConsultantToken();
    
    if (consultantToken == null) {
      return [];
    }

    try {
      final snapshot = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .where('consultantToken', isEqualTo: consultantToken)
            .get()
      );

      final clientsList = <Map<String, dynamic>>[];
      for (final doc in snapshot.docs) {
        final data = doc.data();
        final clientConsultantToken = data['consultantToken'] as String?;
        
        // Verificare explicitƒÉ pentru siguran»õƒÉ
        if (clientConsultantToken == consultantToken) {
          clientsList.add({
            'id': doc.id,
            ...data,
          });
        }
      }
      
      // Sortez local dupa updatedAt (descending)
      clientsList.sort((a, b) {
        final aTime = a['updatedAt'] as Timestamp?;
        final bTime = b['updatedAt'] as Timestamp?;
        
        if (aTime == null && bTime == null) return 0;
        if (aTime == null) return 1;
        if (bTime == null) return -1;
        
        return bTime.compareTo(aTime); // descending
      });
      
      return clientsList;
    } catch (e) {
      debugPrint('‚ùå Error getting all clients: $e');
      return [];
    }
  }

  /// Actualizeaza un client
  Future<bool> updateClient(String phoneNumber, Map<String, dynamic> updates) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      updates['updatedAt'] = FieldValue.serverTimestamp();

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection).doc(phoneNumber).update(updates)
      );
      return true;
    } catch (e) {
      debugPrint('‚ùå Error updating client: $e');
      return false;
    }
  }

  /// Sterge un client si toate sub-colectiile sale
  Future<bool> deleteClient(String phoneNumber) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      final batch = _firestore.batch();
      final clientRef = _firestore.collection(_clientsCollection).doc(phoneNumber);

      // Sterge toate formularele
      final formsSnapshot = await clientRef.collection(_formsSubcollection).get();
      for (final doc in formsSnapshot.docs) {
        batch.delete(doc.reference);
      }

      // Sterge toate intalnirile
      final meetingsSnapshot = await clientRef.collection(_meetingsSubcollection).get();
      for (final doc in meetingsSnapshot.docs) {
        batch.delete(doc.reference);
      }

      // Sterge clientul
      batch.delete(clientRef);

      await _threadHandler.executeOnPlatformThread(() => batch.commit());
      return true;
    } catch (e) {
      debugPrint('‚ùå Error deleting client: $e');
      return false;
    }
  }

  // =================== FORM OPERATIONS ===================

  /// Salveaza un formular pentru un client
  Future<bool> saveClientForm({
    required String phoneNumber,
    required String formId,
    required Map<String, dynamic> formData,
  }) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      final formDoc = {
        'formId': formId,
        'data': formData,
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      };

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_formsSubcollection)
            .doc(formId)
            .set(formDoc)
      );

      // Actualizeaza timestamp-ul clientului
      await updateClient(phoneNumber, {'updatedAt': FieldValue.serverTimestamp()});
      return true;
    } catch (e) {
      debugPrint('‚ùå Error saving form: $e');
      return false;
    }
  }

  /// Obtine toate formularele pentru un client
  Future<List<Map<String, dynamic>>> getClientForms(String phoneNumber) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return [];

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return [];

      final snapshot = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_formsSubcollection)
            .orderBy('updatedAt', descending: true)
            .get()
      );

      return snapshot.docs.map((doc) => {
        'id': doc.id,
        ...doc.data(),
      }).toList();
    } catch (e) {
      debugPrint('‚ùå Error getting client forms: $e');
      return [];
    }
  }

  // =================== MEETING OPERATIONS ===================

  /// OPTIMIZAT: Creeaza o intalnire pentru un client cu performan»õƒÉ √ÆmbunƒÉtƒÉ»õitƒÉ
  Future<bool> createMeeting({
    required String phoneNumber,
    required DateTime dateTime,
    required String type,
    String? description,
    Map<String, dynamic>? additionalData,
  }) async {
    debugPrint('üîç FIREBASE_SERVICE: Starting createMeeting');
    debugPrint('üîç FIREBASE_SERVICE: phoneNumber = "$phoneNumber"');
    debugPrint('üîç FIREBASE_SERVICE: dateTime = $dateTime');
    debugPrint('üîç FIREBASE_SERVICE: type = "$type"');
    debugPrint('üîç FIREBASE_SERVICE: description = "$description"');
    debugPrint('üîç FIREBASE_SERVICE: additionalData = $additionalData');
    
    final consultantToken = await getCurrentConsultantToken();
    debugPrint('üîç FIREBASE_SERVICE: consultantToken = "$consultantToken"');
    if (consultantToken == null) {
      debugPrint('‚ùå FIREBASE_SERVICE: consultantToken is null');
      return false;
    }

    try {
      // OPTIMIZARE: Opera»õii paralele pentru crearea clientului »ôi √Ænt√¢lnirii
      debugPrint('üîç FIREBASE_SERVICE: Starting parallel operations');
      
      final results = await Future.wait([
        // Opera»õia 1: VerificƒÉ/creazƒÉ clientul
        _ensureClientExists(phoneNumber, additionalData, consultantToken),
        // Opera»õia 2: CreeazƒÉ √Ænt√¢lnirea
        _createMeetingDocument(phoneNumber, dateTime, type, description, additionalData, consultantToken),
      ]);
      
      final clientCreated = results[0];
      final meetingCreated = results[1];
      
      debugPrint('üîç FIREBASE_SERVICE: Client created = $clientCreated, Meeting created = $meetingCreated');
      
      if (meetingCreated) {
        debugPrint('‚úÖ FIREBASE_SERVICE: createMeeting completed successfully');
        return true;
      } else {
        debugPrint('‚ùå FIREBASE_SERVICE: Failed to create meeting');
        return false;
      }
    } catch (e) {
      debugPrint('‚ùå FIREBASE_SERVICE: Error creating meeting: $e');
      debugPrint('‚ùå FIREBASE_SERVICE: Stack trace: ${StackTrace.current}');
      return false;
    }
  }

  /// OPTIMIZARE: AsigurƒÉ cƒÉ clientul existƒÉ
  Future<bool> _ensureClientExists(String phoneNumber, Map<String, dynamic>? additionalData, String consultantToken) async {
    try {
      debugPrint('üîç FIREBASE_SERVICE: Checking if client exists');
      final existingClient = await getClient(phoneNumber);
      debugPrint('üîç FIREBASE_SERVICE: existingClient = $existingClient');
      
      // Daca clientul nu exista, il creeaza
      if (existingClient == null) {
        debugPrint('üîç FIREBASE_SERVICE: Client not found, creating new client');
        final clientName = additionalData?['clientName'] ?? 'Client necunoscut';
        final consultantName = additionalData?['consultantName'] ?? 'Consultant necunoscut';
        
        final clientData = {
          'name': clientName,
          'phoneNumber': phoneNumber,
          'consultantToken': consultantToken,
          'consultantName': consultantName,
          'status': 'Nou',
          'createdAt': FieldValue.serverTimestamp(),
          'updatedAt': FieldValue.serverTimestamp(),
        };
        
        debugPrint('üîç FIREBASE_SERVICE: Creating client with data: $clientData');
        await _threadHandler.executeOnPlatformThread(() =>
          _firestore.collection(_clientsCollection)
              .doc(phoneNumber)
              .set(clientData)
        );
        debugPrint('‚úÖ FIREBASE_SERVICE: Client created successfully');
        return true;
      }
      return true;
    } catch (e) {
      debugPrint('‚ùå FIREBASE_SERVICE: Error ensuring client exists: $e');
      return false;
    }
  }

  /// OPTIMIZARE: CreeazƒÉ documentul √Ænt√¢lnirii
  Future<bool> _createMeetingDocument(String phoneNumber, DateTime dateTime, String type, String? description, Map<String, dynamic>? additionalData, String consultantToken) async {
    try {
      debugPrint('üîç FIREBASE_SERVICE: Creating meeting document');
      final meetingDoc = {
        'dateTime': Timestamp.fromDate(dateTime),
        'type': type,
        'description': description,
        'consultantToken': consultantToken,
        'consultantName': additionalData?['consultantName'] ?? 'Consultant necunoscut',
        'clientName': additionalData?['clientName'] ?? 'Client necunoscut',
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
        ...?additionalData,
      };
      debugPrint('üîç FIREBASE_SERVICE: meetingDoc = $meetingDoc');

      debugPrint('üîç FIREBASE_SERVICE: Adding meeting to Firestore');
      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_meetingsSubcollection)
            .add(meetingDoc)
      );
      debugPrint('‚úÖ FIREBASE_SERVICE: Meeting added to Firestore successfully');

      // OPTIMIZARE: ActualizeazƒÉ timestamp-ul clientului √Æn background
      _updateClientTimestampInBackground(phoneNumber);
      
      return true;
    } catch (e) {
      debugPrint('‚ùå FIREBASE_SERVICE: Error creating meeting document: $e');
      return false;
    }
  }

  /// OPTIMIZARE: ActualizeazƒÉ timestamp-ul clientului √Æn background
  void _updateClientTimestampInBackground(String phoneNumber) {
    Future.microtask(() async {
      try {
        debugPrint('üîç FIREBASE_SERVICE: Updating client timestamp in background');
        await updateClient(phoneNumber, {'updatedAt': FieldValue.serverTimestamp()});
        debugPrint('‚úÖ FIREBASE_SERVICE: Client timestamp updated in background');
      } catch (e) {
        debugPrint('‚ùå FIREBASE_SERVICE: Error updating client timestamp in background: $e');
      }
    });
  }

  /// Obtine toate intalnirile pentru consultantul curent (FIX: mai robust filtering)
  Future<List<Map<String, dynamic>>> getAllMeetings() async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) {
      return [];
    }

    try {
      final clients = await getAllClients(); // Folose»ôte getAllClients care deja filtreazƒÉ corect
      final List<Map<String, dynamic>> allMeetings = [];

      for (final client in clients) {
        final phoneNumber = client['phoneNumber'] as String;
        
        // Verificare suplimentarƒÉ pentru siguran»õƒÉ
        if (client['consultantToken'] != consultantToken) {
          continue;
        }
        
        final meetingsSnapshot = await _threadHandler.executeOnPlatformThread(() =>
          _firestore.collection(_clientsCollection)
              .doc(phoneNumber)
              .collection(_meetingsSubcollection)
              .orderBy('dateTime', descending: false)
              .get()
        );

        for (final doc in meetingsSnapshot.docs) {
          // FIX: AsigurƒÉ-te cƒÉ consultantToken este disponibil pentru identificare
          final meetingData = doc.data();
          final additionalData = meetingData['additionalData'] as Map<String, dynamic>? ?? {};
          
          allMeetings.add({
            'id': doc.id,
            'clientPhoneNumber': phoneNumber,
            'clientName': client['name'],
            'consultantToken': consultantToken, // FIX: asigurƒÉ-te cƒÉ este setat corect
            ...meetingData,
            'additionalData': {
              ...additionalData,
              'consultantToken': consultantToken, // FIX: Folose»ôte token-ul pentru identificare
            },
          });
        }
      }

      return allMeetings;
    } catch (e) {
      debugPrint('‚ùå Error getting all meetings: $e');
      return [];
    }
  }

  /// Obtine intalnirile pentru echipa consultantului curent (FIX: mai robust filtering)
  Future<List<Map<String, dynamic>>> getTeamMeetings() async {
    final team = await getCurrentConsultantTeam();
    if (team == null) {
      return [];
    }

    try {
      // Obtine toti consultantii din echipa
      final teamConsultantsSnapshot = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_consultantsCollection)
            .where('team', isEqualTo: team)
            .get()
      );

      final List<String> teamTokens = teamConsultantsSnapshot.docs
          .map((doc) => doc.data()['token'] as String)
          .where((token) => token.isNotEmpty)
          .toList();

      // Obtine clientii pentru toti consultantii din echipa
      final List<Map<String, dynamic>> teamMeetings = [];
      
      for (final token in teamTokens) {
        final clientsSnapshot = await _threadHandler.executeOnPlatformThread(() =>
          _firestore.collection(_clientsCollection)
              .where('consultantToken', isEqualTo: token)
              .get()
        );

        for (final clientDoc in clientsSnapshot.docs) {
          final phoneNumber = clientDoc.id;
          final clientData = clientDoc.data();
          
          // FIX: verificare suplimentarƒÉ pentru siguran»õƒÉ
          if (clientData['consultantToken'] != token) {
            continue;
          }
          
          final meetingsSnapshot = await _threadHandler.executeOnPlatformThread(() =>
            _firestore.collection(_clientsCollection)
                .doc(phoneNumber)
                .collection(_meetingsSubcollection)
                .orderBy('dateTime', descending: false)
                .get()
          );

          for (final meetingDoc in meetingsSnapshot.docs) {
            // FIX: AsigurƒÉ-te cƒÉ consultantToken este disponibil pentru identificare
            final meetingData = meetingDoc.data();
            final additionalData = meetingData['additionalData'] as Map<String, dynamic>? ?? {};
            
            teamMeetings.add({
              'id': meetingDoc.id,
              'clientPhoneNumber': phoneNumber,
              'clientName': clientData['name'],
              'consultantToken': token, // FIX: asigurƒÉ-te cƒÉ este setat corect
              ...meetingData,
              'additionalData': {
                ...additionalData,
                'consultantToken': token, // FIX: Folose»ôte token-ul pentru identificare √Æn calendar
              },
            });
          }
        }
      }

      return teamMeetings;
    } catch (e) {
      debugPrint('‚ùå Error getting team meetings: $e');
      return [];
    }
  }

  /// Actualizeaza o intalnire existenta
  Future<bool> updateMeeting({
    required String phoneNumber,
    required String meetingId,
    DateTime? dateTime,
    String? type,
    String? description,
    Map<String, dynamic>? additionalData,
  }) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      final updates = <String, dynamic>{
        'updatedAt': FieldValue.serverTimestamp(),
      };

      if (dateTime != null) updates['dateTime'] = Timestamp.fromDate(dateTime);
      if (type != null) updates['type'] = type;
      if (description != null) updates['description'] = description;
      if (additionalData != null) updates['additionalData'] = additionalData;

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_meetingsSubcollection)
            .doc(meetingId)
            .update(updates)
      );

      // Actualizeaza timestamp-ul clientului
      await updateClient(phoneNumber, {'updatedAt': FieldValue.serverTimestamp()});
      return true;
    } catch (e) {
      debugPrint('‚ùå Error updating meeting: $e');
      return false;
    }
  }

  /// Sterge o intalnire specifica
  Future<bool> deleteMeeting({
    required String phoneNumber,
    required String meetingId,
  }) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_meetingsSubcollection)
            .doc(meetingId)
            .delete()
      );

      // Actualizeaza timestamp-ul clientului
      await updateClient(phoneNumber, {'updatedAt': FieldValue.serverTimestamp()});
      return true;
    } catch (e) {
      debugPrint('‚ùå Error deleting meeting: $e');
      return false;
    }
  }

  /// Sterge un formular specific
  Future<bool> deleteClientForm({
    required String phoneNumber,
    required String formId,
  }) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_formsSubcollection)
            .doc(formId)
            .delete()
      );

      // Actualizeaza timestamp-ul clientului
      await updateClient(phoneNumber, {'updatedAt': FieldValue.serverTimestamp()});
      return true;
    } catch (e) {
      debugPrint('‚ùå Error deleting form: $e');
      return false;
    }
  }

  // =================== STATS OPERATIONS ===================

  /// Actualizeaza statistici globale
  Future<bool> updateGlobalStats(Map<String, dynamic> stats) async {
    try {
      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_statsCollection).doc('global').set(stats, SetOptions(merge: true))
      );
      return true;
    } catch (e) {
      debugPrint('‚ùå Error updating global stats: $e');
      return false;
    }
  }

  /// Obtine statistici globale
  Future<Map<String, dynamic>?> getGlobalStats() async {
    try {
      final doc = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_statsCollection).doc('global').get()
      );
      return doc.data();
    } catch (e) {
      debugPrint('‚ùå Error getting global stats: $e');
      return null;
    }
  }

  /// Actualizeaza statistici pentru o echipa
  Future<bool> updateTeamStats(String teamName, Map<String, dynamic> stats) async {
    try {
      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_statsCollection).doc('teams').collection(teamName).doc('stats').set(stats, SetOptions(merge: true))
      );
      return true;
    } catch (e) {
      debugPrint('‚ùå Error updating team stats: $e');
      return false;
    }
  }

  // =================== MIGRATION HELPERS ===================

  /// Migreaza datele existente la noua structura
  Future<bool> migrateToNewStructure() async {
    try {
      // Aceasta functie va fi implementata pentru a migra datele existente
      // Dar pentru simplitate, vom incepe cu o structura curata
      
      return true;
    } catch (e) {
      debugPrint('‚ùå Error during migration: $e');
      return false;
    }
  }

  /// Curata structura existenta (ATENTIE: Sterge toate datele!)
  Future<bool> clearOldStructure() async {
    try {
      // ATENTIE: Aceasta functie va sterge toate datele din structura veche!
      // Foloseste-o doar dupa ce ai migrat datele necesare
      
      return true;
    } catch (e) {
      debugPrint('‚ùå Error during cleanup: $e');
      return false;
    }
  }
}

/// Serviciu pentru migrarea datelor la noua structura Firebase
class MigrationService {
  static final MigrationService _instance = MigrationService._internal();
  factory MigrationService() => _instance;
  MigrationService._internal();

  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  /// Incepe migrarea completa la noua structura
  Future<Map<String, dynamic>> startMigration() async {
    try {
      // Pasul 1: Migreaza consultantii
      final consultantsResult = await _migrateConsultants();
      if (!consultantsResult['success']) {
        return consultantsResult;
      }

      // Pasul 2: Migreaza clientii si datele asociate
      final clientsResult = await _migrateClients();
      if (!clientsResult['success']) {
        return clientsResult;
      }

      // Pasul 3: Creeaza structura pentru statistici
      await _createStatsStructure();

      return {
        'success': true,
        'message': 'Migrarea s-a finalizat cu succes',
        'consultantsMigrated': consultantsResult['count'],
        'clientsMigrated': clientsResult['count'],
      };
    } catch (e) {
      debugPrint('‚ùå MIGRATION: Error during migration: $e');
      return {
        'success': false,
        'message': 'Eroare √Æn timpul migrƒÉrii: $e',
      };
    }
  }

  /// Migreaza consultantii la noua structura
  Future<Map<String, dynamic>> _migrateConsultants() async {
    try {
      // Obtine toti consultantii din structura veche
      final oldConsultantsSnapshot = await _firestore.collection('consultants').get();
      int migratedCount = 0;

      for (final doc in oldConsultantsSnapshot.docs) {
        final data = doc.data();
        
        // Verifica daca consultantul are deja token
        if (data.containsKey('token')) {
          migratedCount++;
        }
      }

      return {
        'success': true,
        'count': migratedCount,
      };
    } catch (e) {
      debugPrint('‚ùå MIGRATION: Error migrating consultants: $e');
      return {
        'success': false,
        'message': 'Eroare la migrarea consultantilor: $e',
      };
    }
  }

  /// Migreaza clientii la noua structura
  Future<Map<String, dynamic>> _migrateClients() async {
    try {
      // Pentru noua structura, clientii vor fi creati direct cu noua structura
      // Datele vechi pot fi pastrate pentru backup sau migrate manual
      
      return {
        'success': true,
        'count': 0, // Clientii vor fi creati fresh cu noua structura
      };
    } catch (e) {
      debugPrint('‚ùå MIGRATION: Error preparing client migration: $e');
      return {
        'success': false,
        'message': 'Eroare la migrarea clientilor: $e',
      };
    }
  }

  /// Creeaza structura pentru statistici
  Future<void> _createStatsStructure() async {
    try {
      // Creeaza document global pentru statistici
      await _firestore.collection('stats').doc('global').set({
        'totalClients': 0,
        'totalMeetings': 0,
        'dutyAgent': '',
        'dutyRotation': [],
        'lastUpdated': FieldValue.serverTimestamp(),
        'createdAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      debugPrint('‚ùå MIGRATION: Error creating stats structure: $e');
    }
  }

  /// Verifica daca migrarea este necesara
  Future<bool> isMigrationNeeded() async {
    try {
      // Verifica daca exista structura noua
      final globalStatsDoc = await _firestore.collection('stats').doc('global').get();
      return !globalStatsDoc.exists;
    } catch (e) {
      debugPrint('‚ùå MIGRATION: Error checking migration status: $e');
      return true; // Pe siguranta, presupunem ca migrarea este necesara
    }
  }
}



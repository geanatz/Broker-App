// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;
import 'clients_service.dart';
import 'package:firebase_auth/firebase_auth.dart';

/// Custom logging utility for Firebase operations
class FirebaseLogger {
  static bool _verboseMode = false;
  static final Set<String> _loggedOperations = <String>{};
  static final Map<String, DateTime> _lastLogTime = <String, DateTime>{};
  
  /// Enable/disable verbose logging
  static void setVerboseMode(bool enabled) {
    _verboseMode = enabled;
  }
  
  /// Log important Firebase operations with deduplication
  static void log(String message, {String? tag}) {
    if (_shouldLog(message)) {
      final prefix = tag != null ? '[$tag]' : '[FIREBASE]';
      debugPrint('$prefix $message');
    }
  }
  
  /// Log operations with deduplication to prevent spam
  static void logOperation(String operation, {String? clientId, String? category}) {
    final key = '$operation${clientId != null ? '_$clientId' : ''}${category != null ? '_$category' : ''}';
    final now = DateTime.now();
    
    // Check if we should log this operation (avoid spam)
    if (_shouldLogOperation(key, now)) {
      final emoji = _getEmojiForOperation(operation);
      final message = _formatOperationMessage(operation, clientId, category);
      debugPrint('$emoji $message');
      _loggedOperations.add(key);
      _lastLogTime[key] = now;
    }
  }
  
  /// Check if operation should be logged (prevent spam)
  static bool _shouldLogOperation(String key, DateTime now) {
    final lastTime = _lastLogTime[key];
    if (lastTime == null) return true;
    
    // Don't log the same operation more than once per 2 seconds
    return now.difference(lastTime).inMilliseconds > 2000;
  }
  
  /// Get emoji for operation type
  static String _getEmojiForOperation(String operation) {
    switch (operation.toLowerCase()) {
      case 'added': return '‚ûï';
      case 'removed': return 'üóëÔ∏è';
      case 'modified': return '‚úèÔ∏è';
      case 'category_change': return 'üîÑ';
      case 'sync': return 'üîÑ';
      case 'error': return '‚ùå';
      case 'success': return '‚úÖ';
      default: return 'üìù';
    }
  }
  
  /// Format operation message
  static String _formatOperationMessage(String operation, String? clientId, String? category) {
    if (clientId != null && category != null) {
      return 'CLIENT: $operation - $clientId ‚Üí $category';
    } else if (clientId != null) {
      return 'CLIENT: $operation - $clientId';
    } else {
      return 'FIREBASE: $operation';
    }
  }
  
  /// Log errors
  static void error(String message, [dynamic error, StackTrace? stackTrace]) {
    debugPrint('‚ùå [FIREBASE_ERROR] $message');
    if (error != null && _verboseMode) {
      debugPrint('Error details: $error');
    }
    if (stackTrace != null && _verboseMode) {
      debugPrint('Stack trace: $stackTrace');
    }
  }
  
  /// Log warnings
  static void warning(String message) {
    debugPrint('‚ö†Ô∏è [FIREBASE_WARNING] $message');
  }
  
  /// Log success operations
  static void success(String message) {
    debugPrint('‚úÖ [FIREBASE_SUCCESS] $message');
  }
  
  /// Check if message should be logged based on content
  static bool _shouldLog(String message) {
    // Always log important patterns
    final importantPatterns = [
      'ERROR',
      'Exception',
      'Error',
      'Success',
      'Warning',
      'CRITICAL',
      'FAILED',
    ];
    
    for (final pattern in importantPatterns) {
      if (message.contains(pattern)) {
        return true;
      }
    }
    
    // Filter out verbose Firestore internal logs
    final verbosePatterns = [
      'I/Firestore',
      'target_change',
      'read_time',
      'resume_token',
      'Persistence',
      'WatchStream',
      'document_change',
      'fields {',
      'value {',
      'string_value:',
      'integer_value:',
      'boolean_value:',
      'timestamp_value:',
      'null_value:',
      'map_value {',
      'array_value {',
      'name: "projects/',
      'update_time {',
      'create_time {',
      'nanos:',
      'seconds:',
      'target_ids:',
      'removed_target_ids:',
      'IndexBackfiller',
      'LruGarbageCollector',
      'Collect garbage',
      'Backfill Indexes',
      'Documents written:',
      'Cache size',
      'threshold',
      'No changes detected',
      'Duplicate update detected',
      'Using cached clients',
      'Refreshed clients from Firebase',
      'Real-time update received',
      'Operations update received',
      'Operation detected',
      'Client modified',
      'Category changes detected',
    ];
    
    for (final pattern in verbosePatterns) {
      if (message.contains(pattern)) {
        return false;
      }
    }
    
    // Default: don't log Firebase internal messages
    return !message.contains('I/Firestore') && !message.contains('Firestore(');
  }
}

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'backend/services/firebaseService.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyBmkOMU2YvyJyCa72Lm1D3i62xS9uVISvY',
    appId: '1:324961203074:web:aebb2c8a1fbdd12307559b',
    messagingSenderId: '324961203074',
    projectId: 'broker-app-f1n4nc3',
    authDomain: 'broker-app-f1n4nc3.firebaseapp.com',
    storageBucket: 'broker-app-f1n4nc3.firebasestorage.app',
    measurementId: 'G-RQYQ68D69W',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCr0N-3rXc_KNz5nxM4JG9cCbNLsm8rFu8',
    appId: '1:324961203074:android:a49e09c8f2d20d6807559b',
    messagingSenderId: '324961203074',
    projectId: 'broker-app-f1n4nc3',
    storageBucket: 'broker-app-f1n4nc3.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyAMxDPWmCbHRXL9qhuNxDFzY7f8IY1oHtA',
    appId: '1:324961203074:ios:7f8c65d4099a996207559b',
    messagingSenderId: '324961203074',
    projectId: 'broker-app-f1n4nc3',
    storageBucket: 'broker-app-f1n4nc3.firebasestorage.app',
    iosBundleId: 'com.example.brokerApp',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyAMxDPWmCbHRXL9qhuNxDFzY7f8IY1oHtA',
    appId: '1:324961203074:ios:7f8c65d4099a996207559b',
    messagingSenderId: '324961203074',
    projectId: 'broker-app-f1n4nc3',
    storageBucket: 'broker-app-f1n4nc3.firebasestorage.app',
    iosBundleId: 'com.example.brokerApp',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyBmkOMU2YvyJyCa72Lm1D3i62xS9uVISvY',
    appId: '1:324961203074:web:d67064b2b9ae146707559b',
    messagingSenderId: '324961203074',
    projectId: 'broker-app-f1n4nc3',
    authDomain: 'broker-app-f1n4nc3.firebaseapp.com',
    storageBucket: 'broker-app-f1n4nc3.firebasestorage.app',
    measurementId: 'G-NKE39RD50B',
  );
}

/// Performance monitoring utility
class PerformanceMonitor {
  static final Map<String, Stopwatch> _timers = {};
  static final Map<String, List<int>> _metrics = {};
  
  static void startTimer(String operation) {
    _timers[operation] = Stopwatch()..start();
  }
  
  static void endTimer(String operation) {
    final timer = _timers[operation];
    if (timer != null) {
      timer.stop();
      final duration = timer.elapsedMilliseconds;
      _metrics.putIfAbsent(operation, () => []).add(duration);
      _timers.remove(operation);
    }
  }
  
  static void logMetric(String operation, int duration) {
    _metrics.putIfAbsent(operation, () => []).add(duration);
  }
  
  static Map<String, double> getAverageMetrics() {
    final averages = <String, double>{};
    _metrics.forEach((operation, durations) {
      if (durations.isNotEmpty) {
        averages[operation] = durations.reduce((a, b) => a + b) / durations.length;
      }
    });
    return averages;
  }
  
  static void printPerformanceReport() {
    // Performance reports disabled to reduce log spam
  }
  
  /// Prints a comprehensive performance summary
  static void printComprehensiveReport() {
    // Performance reports disabled to reduce log spam
  }
}

class FirebaseThreadHandler {

  FirebaseThreadHandler._();

  static final FirebaseThreadHandler instance = FirebaseThreadHandler._();

  Future<T> executeOnPlatformThread<T>(Future<T> Function() operation) async {
    final completer = Completer<T>();
    
    void runOperation() async {
      try {
        final result = await operation();
        if (!completer.isCompleted) {
          completer.complete(result);
        }
      } catch (e) {
        FirebaseLogger.error('Error in Firebase operation: $e');
        if (!completer.isCompleted) {
          completer.completeError(e);
        }
      }
    }
    
    // Always schedule on the main thread to prevent threading issues
    WidgetsBinding.instance.addPostFrameCallback((_) => runOperation());
    
    return completer.future;
  }
  
  Stream<QuerySnapshot> createSafeQueryStream(Stream<QuerySnapshot> Function() queryStream) {
    // Create a stream controller that will be responsible for the stream management
    final controller = StreamController<QuerySnapshot>.broadcast();
    
    // Set up proper cancellation handler
    StreamSubscription? subscription;
    controller.onCancel = () {
      subscription?.cancel();
      controller.close();
    };
    
    // Execute on platform thread
    executeOnPlatformThread<void>(() async {
      try {
        // Start the query
        subscription = queryStream().listen(
          (snapshot) {
            if (!controller.isClosed) {
              controller.add(snapshot);
            }
          },
          onError: (error) {
            FirebaseLogger.error("Error in Firestore query: $error");
            if (!controller.isClosed) {
              controller.addError(error);
            }
          },
          onDone: () {
            if (!controller.isClosed) {
              controller.close();
            }
          },
        );
      } catch (e) {
        FirebaseLogger.error("Error setting up Firestore query: $e");
        if (!controller.isClosed) {
          controller.addError(e);
          controller.close();
        }
      }
    });
    
    return controller.stream;
  }
  
  Future<T> executeTransaction<T>(
    Future<T> Function(Transaction transaction) transactionFunction
  ) async {
    return executeOnPlatformThread(() {
      return FirebaseFirestore.instance.runTransaction(transactionFunction);
    });
  }
  
  Future<void> executeBatch(void Function(WriteBatch batch) batchFunction) async {
    return executeOnPlatformThread(() async {
      final batch = FirebaseFirestore.instance.batch();
      batchFunction(batch);
      return batch.commit();
    });
  }
}

/// Serviciu pentru gestionarea formularelor √Æn Firebase Firestore
class FirebaseFormService {
  static final FirebaseFormService _instance = FirebaseFormService._internal();
  factory FirebaseFormService() => _instance;
  FirebaseFormService._internal();

  final ClientsFirebaseService _clientService = ClientsFirebaseService();
  final FirebaseThreadHandler _threadHandler = FirebaseThreadHandler.instance;

  /// SalveazƒÉ datele formularului pentru un client
  Future<bool> saveClientFormData({
    required String phoneNumber,
    required String clientName,
    required Map<String, dynamic> formData,
  }) async {
    try {
      await _threadHandler.executeOnPlatformThread(() async {
        // VerificƒÉ dacƒÉ clientul existƒÉ, dacƒÉ nu √Æl creeazƒÉ
        final existingClient = await _clientService.getClient(phoneNumber);
        if (existingClient == null) {
          // FIX: Nu crea automat clientul dacƒÉ nu existƒÉ - lasƒÉ aplica»õia sƒÉ gestioneze crearea
          FirebaseLogger.warning('Skipping automatic client creation for: $phoneNumber');
          return;
        }

        // SalveazƒÉ datele formularului direct √Æn noua structurƒÉ
        await _clientService.saveClientForm(
          phoneNumber: phoneNumber,
          formType: 'unified_form',
          formData: formData,
        );
      });
      return true;
    } catch (e) {
      FirebaseLogger.error('FirebaseFormService: Error saving form data: $e');
      return false;
    }
  }

  /// OPTIMIZAT: √éncarcƒÉ datele formularului pentru un client din noua structurƒÉ cu cache
  Future<Map<String, dynamic>?> loadClientFormData(String phoneNumber) async {
    try {
      return await _threadHandler.executeOnPlatformThread(() async {
        // OPTIMIZARE: Folose»ôte NewFirebaseService pentru cache
        final newFirebaseService = NewFirebaseService();
        final client = await newFirebaseService.getClient(phoneNumber);
        
        if (client != null) {
          // OPTIMIZARE: Folose»ôte cache-ul pentru form data
          final forms = await newFirebaseService.getClientForms(phoneNumber);
          final formData = forms.isNotEmpty ? forms.first['data'] ?? {} : {};
          
          return {
            'clientName': client['name'],
            'phoneNumber': client['phoneNumber'],
            'lastUpdated': DateTime.now().toIso8601String(),
            'formData': formData,
          };
        }
        return null;
      });
    } catch (e) {
      FirebaseLogger.error('FirebaseFormService: Error loading form data: $e');
      return null;
    }
  }

  /// »òterge datele formularului pentru un client din noua structurƒÉ
  Future<bool> deleteClientFormData(String phoneNumber) async {
    try {
      await _threadHandler.executeOnPlatformThread(() async {
        final forms = await _clientService.getClientForms(phoneNumber);
        for (final form in forms) {
          final newFirebaseService = NewFirebaseService();
          await newFirebaseService.deleteClientForm(
            phoneNumber: phoneNumber,
            formId: form['id'] ?? form['formId'] ?? 'unified_form',
          );
        }
      });
      return true;
    } catch (e) {
      FirebaseLogger.error('Error deleting form data from unified structure: $e');
      return false;
    }
  }

  /// SalveazƒÉ formularele de credit pentru un client
  Future<bool> saveCreditForms({
    required String phoneNumber,
    required String clientName,
    required List<Map<String, dynamic>> clientCreditForms,
    required List<Map<String, dynamic>> coborrowerCreditForms,
  }) async {
    final formData = {
      'creditForms': {
        'client': clientCreditForms,
        'coborrower': coborrowerCreditForms,
      }
    };

    return await saveClientFormData(
      phoneNumber: phoneNumber,
      clientName: clientName,
      formData: formData,
    );
  }

  /// SalveazƒÉ formularele de venit pentru un client
  Future<bool> saveIncomeForms({
    required String phoneNumber,
    required String clientName,
    required List<Map<String, dynamic>> clientIncomeForms,
    required List<Map<String, dynamic>> coborrowerIncomeForms,
  }) async {
    final formData = {
      'incomeForms': {
        'client': clientIncomeForms,
        'coborrower': coborrowerIncomeForms,
      }
    };

    return await saveClientFormData(
      phoneNumber: phoneNumber,
      clientName: clientName,
      formData: formData,
    );
  }

  /// SalveazƒÉ toate datele formularului pentru un client
  Future<bool> saveAllFormData({
    required String phoneNumber,
    required String clientName,
    required List<Map<String, dynamic>> clientCreditForms,
    required List<Map<String, dynamic>> coborrowerCreditForms,
    required List<Map<String, dynamic>> clientIncomeForms,
    required List<Map<String, dynamic>> coborrowerIncomeForms,
    required bool showingClientLoanForm,
    required bool showingClientIncomeForm,
  }) async {
    final formData = {
      'creditForms': {
        'client': clientCreditForms,
        'coborrower': coborrowerCreditForms,
      },
      'incomeForms': {
        'client': clientIncomeForms,
        'coborrower': coborrowerIncomeForms,
      },
      'showingClientLoanForm': showingClientLoanForm,
      'showingClientIncomeForm': showingClientIncomeForm,
    };

    return await saveClientFormData(
      phoneNumber: phoneNumber,
      clientName: clientName,
      formData: formData,
    );
  }

  /// √éncarcƒÉ toate datele formularului pentru un client
  Future<Map<String, dynamic>?> loadAllFormData(String phoneNumber) async {
    try {
      final data = await loadClientFormData(phoneNumber);
      if (data == null) return null;
      
      final formData = data['formData'];
      if (formData == null) return null;
      
      // Ensure type safety by converting dynamic to Map<String, dynamic>
      if (formData is Map) {
        return Map<String, dynamic>.from(formData);
      }
      
      return null;
    } catch (e) {
      FirebaseLogger.error('FirebaseFormService: Error in loadAllFormData: $e');
      return null;
    }
  }

  /// Ob»õine toate documentele din colec»õia forms (pentru debug/admin)
  Future<List<Map<String, dynamic>>> getAllForms() async {
    try {
      return await _threadHandler.executeOnPlatformThread(() async {
        final clients = await _clientService.getAllClients();
        final List<Map<String, dynamic>> allForms = [];
        
        for (final client in clients) {
          final forms = await _clientService.getClientForms(client.phoneNumber);
          final formData = forms.isNotEmpty ? forms.first['data'] ?? {} : {};
          
          allForms.add({
            'id': client.phoneNumber,
            'clientName': client.name,
            'phoneNumber': client.phoneNumber,
            'lastUpdated': DateTime.now().toIso8601String(),
            'formData': formData,
          });
        }
        
        return allForms;
      });
    } catch (e) {
      FirebaseLogger.error('Error getting all forms from unified structure: $e');
      return [];
    }
  }

  /// Stream pentru a asculta schimbƒÉrile √Æn timp real pentru un client
  Stream<Map<String, dynamic>?> streamClientFormData(String phoneNumber) {
    // Pentru compatibilitate, returnƒÉm un stream care emite periodic datele clientului
    return Stream.periodic(const Duration(seconds: 5)).asyncMap((_) async {
      final data = await loadClientFormData(phoneNumber);
      return data;
    });
  }


}

/// Serviciu Firebase refactorizat pentru noua structura
class NewFirebaseService {
  static final NewFirebaseService _instance = NewFirebaseService._internal();
  factory NewFirebaseService() => _instance;
  NewFirebaseService._internal();

  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final FirebaseThreadHandler _threadHandler = FirebaseThreadHandler.instance;

  // Collection names pentru noua structura
  static const String _consultantsCollection = 'consultants';
  static const String _clientsCollection = 'clients';
  static const String _statsCollection = 'stats';
  static const String _formsSubcollection = 'forms';
  static const String _meetingsSubcollection = 'meetings';

  User? get currentUser => _auth.currentUser;

  // Cache pentru token-ul consultantului
  String? _cachedConsultantToken;
  DateTime? _tokenCacheTime;
  static const Duration _tokenCacheDuration = Duration(minutes: 5);

  // OPTIMIZARE: Cache pentru client data
  final Map<String, Map<String, dynamic>> _clientCache = {};
  final Map<String, DateTime> _clientCacheTime = {};
  static const Duration _clientCacheDuration = Duration(minutes: 2);

  // OPTIMIZARE: Cache pentru form data
  final Map<String, Map<String, dynamic>> _formCache = {};
  final Map<String, DateTime> _formCacheTime = {};
  static const Duration _formCacheDuration = Duration(minutes: 5);

  // OPTIMIZARE: Cache pentru all clients list
  List<Map<String, dynamic>>? _allClientsCache;
  DateTime? _allClientsCacheTime;
  static const Duration _allClientsCacheDuration = Duration(seconds: 30);

  /// OPTIMIZARE: Curata cache-ul pentru client data
  void clearClientCache() {
    _clientCache.clear();
    _clientCacheTime.clear();
    _allClientsCache = null;
    _allClientsCacheTime = null;
  }

  /// OPTIMIZARE: Curata cache-ul pentru form data
  void clearFormCache() {
    _formCache.clear();
    _formCacheTime.clear();
  }

  /// OPTIMIZARE: Curata toate cache-urile
  void clearAllCaches() {
    clearClientCache();
    clearFormCache();
    invalidateConsultantTokenCache();
  }

  /// Obtine token-ul consultantului curent din baza de data (cu cache)
  Future<String?> getCurrentConsultantToken() async {
    PerformanceMonitor.startTimer('getCurrentConsultantToken');
    
    // Verifica cache-ul
    if (_cachedConsultantToken != null && _tokenCacheTime != null) {
      final cacheAge = DateTime.now().difference(_tokenCacheTime!);
      if (cacheAge < _tokenCacheDuration) {
        // Only log cache usage occasionally to reduce spam
        if (cacheAge.inMilliseconds % 10000 < 100) { // Log only every ~10 seconds
      
        }
        PerformanceMonitor.endTimer('getCurrentConsultantToken');
        return _cachedConsultantToken;
      }
    }
    
    return await _threadHandler.executeOnPlatformThread(() async {
      final user = currentUser;
      if (user == null) {
        FirebaseLogger.error('getCurrentConsultantToken currentUser is null');
        PerformanceMonitor.endTimer('getCurrentConsultantToken');
        return null;
      }

      try {
        final doc = await _firestore.collection(_consultantsCollection).doc(user.uid).get();
      
        if (doc.exists) {
          final data = doc.data();
          final token = data?['token'] as String?;
          
          if (token == null || token.isEmpty) {
            FirebaseLogger.error('getCurrentConsultantToken token is null or empty');
            PerformanceMonitor.endTimer('getCurrentConsultantToken');
            return null;
          } else {
        
            
            // Salveaza in cache
            _cachedConsultantToken = token;
            _tokenCacheTime = DateTime.now();
            
            PerformanceMonitor.endTimer('getCurrentConsultantToken');
            return token;
          }
        } else {
          FirebaseLogger.error('Consultant document does not exist for UID: ${user.uid}');
          PerformanceMonitor.endTimer('getCurrentConsultantToken');
          return null;
        }
      } catch (e) {
        FirebaseLogger.error('FirebaseService: Error getting consultant token: $e');
        PerformanceMonitor.endTimer('getCurrentConsultantToken');
        return null;
      }
    });
  }

  /// Invalideaza cache-ul pentru token-ul consultantului
  void invalidateConsultantTokenCache() {
    _cachedConsultantToken = null;
    _tokenCacheTime = null;

  }

  /// Obtine datele consultantului pe baza token-ului
  Future<Map<String, dynamic>?> getConsultantByToken(String token) async {
    try {
      final snapshot = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_consultantsCollection)
            .where('token', isEqualTo: token)
            .limit(1)
            .get()
      );

      if (snapshot.docs.isNotEmpty) {
        return snapshot.docs.first.data();
      }
      return null;
    } catch (e) {
      FirebaseLogger.error('Error getting consultant by token: $e');
      return null;
    }
  }

  /// Obtine echipa consultantului curent
  Future<String?> getCurrentConsultantTeam() async {
    final token = await getCurrentConsultantToken();
    if (token == null) return null;

    final consultantData = await getConsultantByToken(token);
    return consultantData?['team'] as String?;
  }

  // =================== CLIENT OPERATIONS ===================

  /// Creeaza un client nou pentru consultantul curent
  Future<bool> createClient({
    required String phoneNumber,
    required String name,
    String? coDebitorName,
    String? status,
    String? category,
    Map<String, dynamic>? additionalData,
  }) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      final clientData = {
        'consultantToken': consultantToken,
        'name': name,
        'phoneNumber': phoneNumber,
        'coDebitorName': coDebitorName,
        'status': status ?? 'normal',
        'category': category ?? 'clienti',
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
        ...?additionalData,
      };

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection).doc(phoneNumber).set(clientData)
      );
      return true;
    } catch (e) {
      FirebaseLogger.error('Error creating client: $e');
      return false;
    }
  }

  /// OPTIMIZAT: Obtine un client dupa numarul de telefon cu cache (doar pentru consultantul curent)
  Future<Map<String, dynamic>?> getClient(String phoneNumber) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) {
      FirebaseLogger.error('getClient consultantToken is null');
      return null;
    }

    // OPTIMIZARE: Verifica cache-ul mai intai
    if (_clientCache.containsKey(phoneNumber)) {
      final cacheTime = _clientCacheTime[phoneNumber];
      if (cacheTime != null && DateTime.now().difference(cacheTime) < _clientCacheDuration) {
        final cachedData = _clientCache[phoneNumber]!;
        if (cachedData['consultantToken'] == consultantToken) {
          return cachedData;
        }
      }
    }

    try {
      final doc = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection).doc(phoneNumber).get()
      );

      final data = doc.data();
      
      if (data != null && data['consultantToken'] == consultantToken) {
        // OPTIMIZARE: Salveaza in cache
        _clientCache[phoneNumber] = data;
        _clientCacheTime[phoneNumber] = DateTime.now();
        
        FirebaseLogger.success('getClient found matching client');
        return data;
      } else {
        FirebaseLogger.error('getClient no matching client found');
        return null;
      }
    } catch (e) {
      FirebaseLogger.error('FirebaseService: getClient error: $e');
      return null;
    }
  }

  // =================== REAL-TIME LISTENERS ===================

  /// Creeaza un stream real-time pentru clientii consultantului curent
  Stream<List<Map<String, dynamic>>> getClientsRealTimeStream() async* {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) {
      FirebaseLogger.error('No consultant token for real-time stream');
      return;
    }


    
    try {
      // FIX: Use a simpler query that doesn't require composite indexes
      final query = _firestore
          .collection(_clientsCollection)
          .where('consultantToken', isEqualTo: consultantToken);

      // Returneaza stream-ul de snapshots
      yield* query.snapshots().map((snapshot) {
        final clients = snapshot.docs.map((doc) {
          final data = doc.data();
          data['id'] = doc.id; // Adauga ID-ul documentului
          return data;
        }).toList();
        
        // FIX: Sort locally to avoid index requirements
        clients.sort((a, b) {
          final aTime = a['updatedAt'] as Timestamp?;
          final bTime = b['updatedAt'] as Timestamp?;
          
          if (aTime == null && bTime == null) return 0;
          if (aTime == null) return 1;
          if (bTime == null) return -1;
          
          return bTime.compareTo(aTime); // descending
        });
        
        // Only log significant changes
        if (clients.isNotEmpty) {
      
        }
        return clients;
      }).handleError((error) {
        FirebaseLogger.error('Real-time stream error: $error');
        // FIX: Return empty list on error to prevent crashes
        return <Map<String, dynamic>>[];
      });
    } catch (e) {
      FirebaseLogger.error('Error creating real-time stream: $e');
      // FIX: Return empty stream on error
      yield* Stream.value(<Map<String, dynamic>>[]);
    }
  }

  /// Creeaza un stream real-time pentru un client specific
  Stream<Map<String, dynamic>?> getClientRealTimeStream(String phoneNumber) async* {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) {
      debugPrint('‚ùå FIREBASE_SERVICE: No consultant token for client stream');
      return;
    }


    
    // Creeaza query-ul pentru clientul specific
    final query = _firestore
        .collection(_clientsCollection)
        .doc(phoneNumber)
        .snapshots();

    // Returneaza stream-ul de snapshots
    yield* query.map((snapshot) {
      if (snapshot.exists) {
        final data = snapshot.data() as Map<String, dynamic>;
        // Verifica daca clientul apartine consultantului curent
        if (data['consultantToken'] == consultantToken) {
          data['id'] = snapshot.id;
      
          return data;
        }
      }
      debugPrint('üîÑ FIREBASE_SERVICE: Client not found or not accessible');
      return null;
    });
  }

  /// Creeaza un stream real-time pentru clientii dintr-o categorie specifica
  Stream<List<Map<String, dynamic>>> getClientsByCategoryRealTimeStream(String category) async* {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) {
      debugPrint('‚ùå FIREBASE_SERVICE: No consultant token for category stream');
      return;
    }


    
    // Creeaza query-ul pentru categoria specifica
    final query = _firestore
        .collection(_clientsCollection)
        .where('consultantToken', isEqualTo: consultantToken)
        .where('category', isEqualTo: category)
        .orderBy('updatedAt', descending: true);

    // Returneaza stream-ul de snapshots
    yield* query.snapshots().map((snapshot) {
      final clients = snapshot.docs.map((doc) {
        final data = doc.data();
        data['id'] = doc.id;
        return data;
      }).toList();
      
  
      return clients;
    });
  }

  /// Creeaza un stream real-time pentru clientii cu un status specific
  Stream<List<Map<String, dynamic>>> getClientsByStatusRealTimeStream(String status) async* {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) {
      debugPrint('‚ùå FIREBASE_SERVICE: No consultant token for status stream');
      return;
    }


    
    // Creeaza query-ul pentru statusul specific
    final query = _firestore
        .collection(_clientsCollection)
        .where('consultantToken', isEqualTo: consultantToken)
        .where('status', isEqualTo: status)
        .orderBy('updatedAt', descending: true);

    // Returneaza stream-ul de snapshots
    yield* query.snapshots().map((snapshot) {
      final clients = snapshot.docs.map((doc) {
        final data = doc.data();
        data['id'] = doc.id;
        return data;
      }).toList();
      
  
      return clients;
    });
  }

  /// Creeaza un stream real-time pentru operatiunile clientilor cu detectare avansata de schimbari
  Stream<Map<String, dynamic>> getClientsOperationsRealTimeStream() async* {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) {
      FirebaseLogger.error('No consultant token for operations stream');
      return;
    }


    
    try {
      // FIX: Use a simpler query that doesn't require composite indexes
      final query = _firestore
          .collection(_clientsCollection)
          .where('consultantToken', isEqualTo: consultantToken);

      // Returneaza stream-ul de snapshots cu informatii despre operatiuni
      yield* query.snapshots().map((snapshot) {
        final operations = <String, dynamic>{
          'timestamp': DateTime.now().toIso8601String(),
          'totalClients': snapshot.docs.length,
          'changes': snapshot.docChanges.map((change) {
            final data = change.doc.data();
            final isCategoryChange = change.type.name == 'modified' && 
                data != null && 
                data.containsKey('category') && 
                data['category'] != null;
            
            return {
              'type': change.type.name, // 'added', 'modified', 'removed'
              'clientId': change.doc.id,
              'clientData': data,
              'oldIndex': change.oldIndex,
              'newIndex': change.newIndex,
              // FIX: Detect category changes specifically for mobile sync
              'isCategoryChange': isCategoryChange,
              'category': data?['category'],
              'name': data?['name'] ?? '',
              'phoneNumber': data?['phoneNumber'] ?? '',
            };
          }).toList(),
        };
        
        // FIX: Log only significant operations, not every update
        final significantChanges = operations['changes'].where((change) => 
            change['type'] == 'added' || change['type'] == 'removed' || 
            (change['isCategoryChange'] == true)).toList();
        
        if (significantChanges.isNotEmpty) {
          for (final change in significantChanges) {
            if (change['type'] == 'added') {
              FirebaseLogger.logOperation('added', clientId: change['phoneNumber'], category: change['name']);
            } else if (change['type'] == 'removed') {
              FirebaseLogger.logOperation('removed', clientId: change['phoneNumber'], category: change['name']);
            } else if (change['isCategoryChange'] == true) {
              FirebaseLogger.logOperation('category_change', clientId: change['phoneNumber'], category: change['category']);
            }
          }
        }
        
        return operations;
      }).handleError((error) {
        FirebaseLogger.error('Operations stream error: $error');
        // FIX: Return empty operations on error
        return <String, dynamic>{
          'timestamp': DateTime.now().toIso8601String(),
          'totalClients': 0,
          'changes': <Map<String, dynamic>>[],
        };
      });
    } catch (e) {
      FirebaseLogger.error('Error creating operations stream: $e');
      // FIX: Return empty operations stream on error
      yield* Stream.value(<String, dynamic>{
        'timestamp': DateTime.now().toIso8601String(),
        'totalClients': 0,
        'changes': <Map<String, dynamic>>[],
      });
    }
  }

  /// OPTIMIZAT: Obtine toti clientii pentru consultantul curent cu cache
  Future<List<Map<String, dynamic>>> getAllClients() async {
    final consultantToken = await getCurrentConsultantToken();
    
    if (consultantToken == null) {
      return [];
    }

    // OPTIMIZARE: Verifica cache-ul pentru all clients
    if (_allClientsCache != null && _allClientsCacheTime != null) {
      final cacheAge = DateTime.now().difference(_allClientsCacheTime!);
      if (cacheAge < _allClientsCacheDuration) {
        return _allClientsCache!;
      }
    }

    try {
      final snapshot = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .where('consultantToken', isEqualTo: consultantToken)
            .get()
      );

      final clientsList = <Map<String, dynamic>>[];
      for (final doc in snapshot.docs) {
        final data = doc.data();
        final clientConsultantToken = data['consultantToken'] as String?;
        
        // Verificare explicitƒÉ pentru siguran»õƒÉ
        if (clientConsultantToken == consultantToken) {
          clientsList.add({
            'id': doc.id,
            ...data,
          });
        }
      }
      
      // Sortez local dupa updatedAt (descending)
      clientsList.sort((a, b) {
        final aTime = a['updatedAt'] as Timestamp?;
        final bTime = b['updatedAt'] as Timestamp?;
        
        if (aTime == null && bTime == null) return 0;
        if (aTime == null) return 1;
        if (bTime == null) return -1;
        
        return bTime.compareTo(aTime); // descending
      });
      
      // OPTIMIZARE: Salveaza in cache
      _allClientsCache = clientsList;
      _allClientsCacheTime = DateTime.now();
      
      return clientsList;
    } catch (e) {
      FirebaseLogger.error('Error getting all clients: $e');
      return [];
    }
  }

  /// OPTIMIZAT: Actualizeaza un client cu invalidare cache
  Future<bool> updateClient(String phoneNumber, Map<String, dynamic> updates) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      updates['updatedAt'] = FieldValue.serverTimestamp();

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection).doc(phoneNumber).update(updates)
      );
      
      // OPTIMIZARE: Invalideaza cache-ul pentru client
      invalidateClientCache(phoneNumber);
      invalidateAllClientsCache();
      
      return true;
    } catch (e) {
      FirebaseLogger.error('Error updating client: $e');
      return false;
    }
  }

  /// Sterge un client si toate sub-colectiile sale
  Future<bool> deleteClient(String phoneNumber) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      final batch = _firestore.batch();
      final clientRef = _firestore.collection(_clientsCollection).doc(phoneNumber);

      // Sterge toate formularele
      final formsSnapshot = await clientRef.collection(_formsSubcollection).get();
      for (final doc in formsSnapshot.docs) {
        batch.delete(doc.reference);
      }

      // Sterge toate intalnirile
      final meetingsSnapshot = await clientRef.collection(_meetingsSubcollection).get();
      for (final doc in meetingsSnapshot.docs) {
        batch.delete(doc.reference);
      }

      // Sterge clientul
      batch.delete(clientRef);

      await _threadHandler.executeOnPlatformThread(() => batch.commit());
      return true;
    } catch (e) {
      FirebaseLogger.error('Error deleting client: $e');
      return false;
    }
  }

  // =================== FORM OPERATIONS ===================

  /// Salveaza un formular pentru un client
  Future<bool> saveClientForm({
    required String phoneNumber,
    required String formId,
    required Map<String, dynamic> formData,
  }) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      final formDoc = {
        'formId': formId,
        'data': formData,
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      };

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_formsSubcollection)
            .doc(formId)
            .set(formDoc)
      );

      // OPTIMIZARE: Invalideaza cache-ul pentru form data
      invalidateFormCache(phoneNumber);
      
      // Actualizeaza timestamp-ul clientului
      await updateClient(phoneNumber, {'updatedAt': FieldValue.serverTimestamp()});
      return true;
    } catch (e) {
      FirebaseLogger.error('Error saving form: $e');
      return false;
    }
  }

  /// Obtine toate formularele pentru un client
  /// OPTIMIZAT: Obtine formularele unui client cu cache
  Future<List<Map<String, dynamic>>> getClientForms(String phoneNumber) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return [];

    // OPTIMIZARE: Verifica cache-ul pentru form data
    final cacheKey = '${phoneNumber}_forms';
    if (_formCache.containsKey(cacheKey)) {
      final cacheTime = _formCacheTime[cacheKey];
      if (cacheTime != null && DateTime.now().difference(cacheTime) < _formCacheDuration) {
        final cachedForms = _formCache[cacheKey]!['forms'] as List<Map<String, dynamic>>?;
        if (cachedForms != null) {
          return cachedForms;
        }
      }
    }

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return [];

      final snapshot = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_formsSubcollection)
            .orderBy('updatedAt', descending: true)
            .get()
      );

      final forms = snapshot.docs.map((doc) => {
        'id': doc.id,
        ...doc.data(),
      }).toList();

      // OPTIMIZARE: Salveaza in cache
      _formCache[cacheKey] = {'forms': forms};
      _formCacheTime[cacheKey] = DateTime.now();

      return forms;
    } catch (e) {
      FirebaseLogger.error('Error getting client forms: $e');
      return [];
    }
  }

  // =================== MEETING OPERATIONS ===================

  /// OPTIMIZAT: Creeaza o intalnire pentru un client cu performan»õƒÉ √ÆmbunƒÉtƒÉ»õitƒÉ
  Future<bool> createMeeting({
    required String phoneNumber,
    required DateTime dateTime,
    required String type,
    String? description,
    Map<String, dynamic>? additionalData,
  }) async {

    
    final consultantToken = await getCurrentConsultantToken();

    if (consultantToken == null) {
      debugPrint('‚ùå FIREBASE_SERVICE: consultantToken is null');
      return false;
    }

    try {
      // OPTIMIZARE: Opera»õii paralele pentru crearea clientului »ôi √Ænt√¢lnirii
  
      
      final results = await Future.wait([
        // Opera»õia 1: VerificƒÉ/creazƒÉ clientul
        _ensureClientExists(phoneNumber, additionalData, consultantToken),
        // Opera»õia 2: CreeazƒÉ √Ænt√¢lnirea
        _createMeetingDocument(phoneNumber, dateTime, type, description, additionalData, consultantToken),
      ]);
      
      final meetingCreated = results[1];
      
  
      
      if (meetingCreated) {
    
        return true;
      } else {
    
        return false;
      }
    } catch (e) {
      FirebaseLogger.error('Error creating meeting: $e');
  
      return false;
    }
  }

  /// OPTIMIZARE: AsigurƒÉ cƒÉ clientul existƒÉ
  Future<bool> _ensureClientExists(String phoneNumber, Map<String, dynamic>? additionalData, String consultantToken) async {
    try {
  
      final existingClient = await getClient(phoneNumber);
  
      
      // Daca clientul nu exista, il creeaza
      if (existingClient == null) {
    
        final clientName = additionalData?['clientName'] ?? 'Client necunoscut';
        final consultantName = additionalData?['consultantName'] ?? 'Consultant necunoscut';
        
        final clientData = {
          'name': clientName,
          'phoneNumber': phoneNumber,
          'consultantToken': consultantToken,
          'consultantName': consultantName,
          'status': 'Nou',
          'createdAt': FieldValue.serverTimestamp(),
          'updatedAt': FieldValue.serverTimestamp(),
        };
        
    
        await _threadHandler.executeOnPlatformThread(() =>
          _firestore.collection(_clientsCollection)
              .doc(phoneNumber)
              .set(clientData)
        );
    
        return true;
      }
      return true;
    } catch (e) {
      FirebaseLogger.error('Error ensuring client exists: $e');
      return false;
    }
  }

  /// OPTIMIZARE: CreeazƒÉ documentul √Ænt√¢lnirii
  Future<bool> _createMeetingDocument(String phoneNumber, DateTime dateTime, String type, String? description, Map<String, dynamic>? additionalData, String consultantToken) async {
    try {
  
      final meetingDoc = {
        'dateTime': Timestamp.fromDate(dateTime),
        'type': type,
        'description': description,
        'consultantToken': consultantToken,
        'consultantName': additionalData?['consultantName'] ?? 'Consultant necunoscut',
        'clientName': additionalData?['clientName'] ?? 'Client necunoscut',
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
        ...?additionalData,
      };
  

  
      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_meetingsSubcollection)
            .add(meetingDoc)
      );
  

      // OPTIMIZARE: ActualizeazƒÉ timestamp-ul clientului √Æn background
      _updateClientTimestampInBackground(phoneNumber);
      
      return true;
    } catch (e) {
      FirebaseLogger.error('Error creating meeting document: $e');
      return false;
    }
  }

  /// OPTIMIZARE: ActualizeazƒÉ timestamp-ul clientului √Æn background
  void _updateClientTimestampInBackground(String phoneNumber) {
    Future.microtask(() async {
      try {
    
        await updateClient(phoneNumber, {'updatedAt': FieldValue.serverTimestamp()});
    
      } catch (e) {
        FirebaseLogger.error('Error updating client timestamp in background: $e');
      }
    });
  }

  /// Obtine toate intalnirile pentru consultantul curent (FIX: mai robust filtering)
  Future<List<Map<String, dynamic>>> getAllMeetings() async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) {
      return [];
    }

    try {
      final clients = await getAllClients(); // Folose»ôte getAllClients care deja filtreazƒÉ corect
      final List<Map<String, dynamic>> allMeetings = [];

      for (final client in clients) {
        final phoneNumber = client['phoneNumber'] as String;
        
        // Verificare suplimentarƒÉ pentru siguran»õƒÉ
        if (client['consultantToken'] != consultantToken) {
          continue;
        }
        
        final meetingsSnapshot = await _threadHandler.executeOnPlatformThread(() =>
          _firestore.collection(_clientsCollection)
              .doc(phoneNumber)
              .collection(_meetingsSubcollection)
              .orderBy('dateTime', descending: false)
              .get()
        );

        for (final doc in meetingsSnapshot.docs) {
          // FIX: AsigurƒÉ-te cƒÉ consultantToken este disponibil pentru identificare
          final meetingData = doc.data();
          final additionalData = meetingData['additionalData'] as Map<String, dynamic>? ?? {};
          
          allMeetings.add({
            'id': doc.id,
            'clientPhoneNumber': phoneNumber,
            'clientName': client['name'],
            'consultantToken': consultantToken, // FIX: asigurƒÉ-te cƒÉ este setat corect
            ...meetingData,
            'additionalData': {
              ...additionalData,
              'consultantToken': consultantToken, // FIX: Folose»ôte token-ul pentru identificare
            },
          });
        }
      }

      return allMeetings;
    } catch (e) {
      FirebaseLogger.error('Error getting all meetings: $e');
      return [];
    }
  }

  /// Obtine intalnirile pentru echipa consultantului curent (FIX: mai robust filtering)
  Future<List<Map<String, dynamic>>> getTeamMeetings() async {
    final team = await getCurrentConsultantTeam();
    if (team == null) {
      return [];
    }

    try {
      // Obtine toti consultantii din echipa
      final teamConsultantsSnapshot = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_consultantsCollection)
            .where('team', isEqualTo: team)
            .get()
      );

      final List<String> teamTokens = teamConsultantsSnapshot.docs
          .map((doc) => doc.data()['token'] as String)
          .where((token) => token.isNotEmpty)
          .toList();

      // Obtine clientii pentru toti consultantii din echipa
      final List<Map<String, dynamic>> teamMeetings = [];
      
      for (final token in teamTokens) {
        final clientsSnapshot = await _threadHandler.executeOnPlatformThread(() =>
          _firestore.collection(_clientsCollection)
              .where('consultantToken', isEqualTo: token)
              .get()
        );

        for (final clientDoc in clientsSnapshot.docs) {
          final phoneNumber = clientDoc.id;
          final clientData = clientDoc.data();
          
          // FIX: verificare suplimentarƒÉ pentru siguran»õƒÉ
          if (clientData['consultantToken'] != token) {
            continue;
          }
          
          final meetingsSnapshot = await _threadHandler.executeOnPlatformThread(() =>
            _firestore.collection(_clientsCollection)
                .doc(phoneNumber)
                .collection(_meetingsSubcollection)
                .orderBy('dateTime', descending: false)
                .get()
          );

          for (final meetingDoc in meetingsSnapshot.docs) {
            // FIX: AsigurƒÉ-te cƒÉ consultantToken este disponibil pentru identificare
            final meetingData = meetingDoc.data();
            final additionalData = meetingData['additionalData'] as Map<String, dynamic>? ?? {};
            
            teamMeetings.add({
              'id': meetingDoc.id,
              'clientPhoneNumber': phoneNumber,
              'clientName': clientData['name'],
              'consultantToken': token, // FIX: asigurƒÉ-te cƒÉ este setat corect
              ...meetingData,
              'additionalData': {
                ...additionalData,
                'consultantToken': token, // FIX: Folose»ôte token-ul pentru identificare √Æn calendar
              },
            });
          }
        }
      }

      return teamMeetings;
    } catch (e) {
      FirebaseLogger.error('Error getting team meetings: $e');
      return [];
    }
  }

  /// Actualizeaza o intalnire existenta
  Future<bool> updateMeeting({
    required String phoneNumber,
    required String meetingId,
    DateTime? dateTime,
    String? type,
    String? description,
    Map<String, dynamic>? additionalData,
  }) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      final updates = <String, dynamic>{
        'updatedAt': FieldValue.serverTimestamp(),
      };

      if (dateTime != null) updates['dateTime'] = Timestamp.fromDate(dateTime);
      if (type != null) updates['type'] = type;
      if (description != null) updates['description'] = description;
      if (additionalData != null) updates['additionalData'] = additionalData;

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_meetingsSubcollection)
            .doc(meetingId)
            .update(updates)
      );

      // Actualizeaza timestamp-ul clientului
      await updateClient(phoneNumber, {'updatedAt': FieldValue.serverTimestamp()});
      return true;
    } catch (e) {
      FirebaseLogger.error('Error updating meeting: $e');
      return false;
    }
  }

  /// Sterge o intalnire specifica
  Future<bool> deleteMeeting({
    required String phoneNumber,
    required String meetingId,
  }) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_meetingsSubcollection)
            .doc(meetingId)
            .delete()
      );

      // Actualizeaza timestamp-ul clientului
      await updateClient(phoneNumber, {'updatedAt': FieldValue.serverTimestamp()});
      return true;
    } catch (e) {
      FirebaseLogger.error('Error deleting meeting: $e');
      return false;
    }
  }

  /// Sterge un formular specific
  Future<bool> deleteClientForm({
    required String phoneNumber,
    required String formId,
  }) async {
    final consultantToken = await getCurrentConsultantToken();
    if (consultantToken == null) return false;

    try {
      // Verifica daca clientul apartine consultantului curent
      final existingClient = await getClient(phoneNumber);
      if (existingClient == null) return false;

      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_clientsCollection)
            .doc(phoneNumber)
            .collection(_formsSubcollection)
            .doc(formId)
            .delete()
      );

      // Actualizeaza timestamp-ul clientului
      await updateClient(phoneNumber, {'updatedAt': FieldValue.serverTimestamp()});
      return true;
    } catch (e) {
      FirebaseLogger.error('Error deleting form: $e');
      return false;
    }
  }

  // =================== STATS OPERATIONS ===================

  /// Actualizeaza statistici globale
  Future<bool> updateGlobalStats(Map<String, dynamic> stats) async {
    try {
      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_statsCollection).doc('global').set(stats, SetOptions(merge: true))
      );
      return true;
    } catch (e) {
      FirebaseLogger.error('Error updating global stats: $e');
      return false;
    }
  }

  /// Obtine statistici globale
  Future<Map<String, dynamic>?> getGlobalStats() async {
    try {
      final doc = await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_statsCollection).doc('global').get()
      );
      return doc.data();
    } catch (e) {
      FirebaseLogger.error('Error getting global stats: $e');
      return null;
    }
  }

  /// Actualizeaza statistici pentru o echipa
  Future<bool> updateTeamStats(String teamName, Map<String, dynamic> stats) async {
    try {
      await _threadHandler.executeOnPlatformThread(() =>
        _firestore.collection(_statsCollection).doc('teams').collection(teamName).doc('stats').set(stats, SetOptions(merge: true))
      );
      return true;
    } catch (e) {
      FirebaseLogger.error('Error updating team stats: $e');
      return false;
    }
  }

  // =================== MIGRATION HELPERS ===================

  /// Migreaza datele existente la noua structura
  Future<bool> migrateToNewStructure() async {
    try {
      // Aceasta functie va fi implementata pentru a migra datele existente
      // Dar pentru simplitate, vom incepe cu o structura curata
      
      return true;
    } catch (e) {
      FirebaseLogger.error('Error during migration: $e');
      return false;
    }
  }

  /// Curata structura existenta (ATENTIE: Sterge toate datele!)
  Future<bool> clearOldStructure() async {
    try {
      // ATENTIE: Aceasta functie va sterge toate datele din structura veche!
      // Foloseste-o doar dupa ce ai migrat datele necesare
      
      return true;
    } catch (e) {
      FirebaseLogger.error('Error during cleanup: $e');
      return false;
    }
  }

  /// OPTIMIZARE: Invalideaza cache-ul pentru un client specific
  void invalidateClientCache(String phoneNumber) {
    _clientCache.remove(phoneNumber);
    _clientCacheTime.remove(phoneNumber);
  }

  /// OPTIMIZARE: Invalideaza cache-ul pentru form data pentru un client specific
  void invalidateFormCache(String phoneNumber) {
    final cacheKey = '${phoneNumber}_forms';
    _formCache.remove(cacheKey);
    _formCacheTime.remove(cacheKey);
  }

  /// OPTIMIZARE: Invalideaza toate cache-urile pentru un client
  void invalidateAllCachesForClient(String phoneNumber) {
    invalidateClientCache(phoneNumber);
    invalidateFormCache(phoneNumber);
  }

  /// OPTIMIZARE: Invalideaza cache-ul pentru all clients
  void invalidateAllClientsCache() {
    _allClientsCache = null;
    _allClientsCacheTime = null;
  }
}

/// Serviciu pentru migrarea datelor la noua structura Firebase
class MigrationService {
  static final MigrationService _instance = MigrationService._internal();
  factory MigrationService() => _instance;
  MigrationService._internal();

  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  /// Incepe migrarea completa la noua structura
  Future<Map<String, dynamic>> startMigration() async {
    try {
      // Pasul 1: Migreaza consultantii
      final consultantsResult = await _migrateConsultants();
      if (!consultantsResult['success']) {
        return consultantsResult;
      }

      // Pasul 2: Migreaza clientii si datele asociate
      final clientsResult = await _migrateClients();
      if (!clientsResult['success']) {
        return clientsResult;
      }

      // Pasul 3: Creeaza structura pentru statistici
      await _createStatsStructure();

      return {
        'success': true,
        'message': 'Migrarea s-a finalizat cu succes',
        'consultantsMigrated': consultantsResult['count'],
        'clientsMigrated': clientsResult['count'],
      };
    } catch (e) {
      FirebaseLogger.error('Error during migration: $e');
      return {
        'success': false,
        'message': 'Eroare √Æn timpul migrƒÉrii: $e',
      };
    }
  }

  /// Migreaza consultantii la noua structura
  Future<Map<String, dynamic>> _migrateConsultants() async {
    try {
      // Obtine toti consultantii din structura veche
      final oldConsultantsSnapshot = await _firestore.collection('consultants').get();
      int migratedCount = 0;

      for (final doc in oldConsultantsSnapshot.docs) {
        final data = doc.data();
        
        // Verifica daca consultantul are deja token
        if (data.containsKey('token')) {
          migratedCount++;
        }
      }

      return {
        'success': true,
        'count': migratedCount,
      };
    } catch (e) {
      FirebaseLogger.error('Error migrating consultants: $e');
      return {
        'success': false,
        'message': 'Eroare la migrarea consultantilor: $e',
      };
    }
  }

  /// Migreaza clientii la noua structura
  Future<Map<String, dynamic>> _migrateClients() async {
    try {
      // Pentru noua structura, clientii vor fi creati direct cu noua structura
      // Datele vechi pot fi pastrate pentru backup sau migrate manual
      
      return {
        'success': true,
        'count': 0, // Clientii vor fi creati fresh cu noua structura
      };
    } catch (e) {
      FirebaseLogger.error('Error preparing client migration: $e');
      return {
        'success': false,
        'message': 'Eroare la migrarea clientilor: $e',
      };
    }
  }

  /// Creeaza structura pentru statistici
  Future<void> _createStatsStructure() async {
    try {
      // Creeaza document global pentru statistici
      await _firestore.collection('stats').doc('global').set({
        'totalClients': 0,
        'totalMeetings': 0,
        'dutyAgent': '',
        'dutyRotation': [],
        'lastUpdated': FieldValue.serverTimestamp(),
        'createdAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      FirebaseLogger.error('Error creating stats structure: $e');
    }
  }

  /// Verifica daca migrarea este necesara
  Future<bool> isMigrationNeeded() async {
    try {
      // Verifica daca exista structura noua
      final globalStatsDoc = await _firestore.collection('stats').doc('global').get();
      return !globalStatsDoc.exists;
    } catch (e) {
      FirebaseLogger.error('Error checking migration status: $e');
      return true; // Pe siguranta, presupunem ca migrarea este necesara
    }
  }
}


